<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe Validator - Steam 리뷰 기반 아이디어 검증</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-body: #F5F4F0;
            --bg-card: #FAFAF8;
            --bg-sidebar: #FFFFFF;
            --bg-input: #FFFFFF;
            --border-light: #E8E6E1;
            --border-medium: #D4D2CD;
            --text-primary: #1A1A1A;
            --text-secondary: #6B6B6B;
            --text-muted: #9B9B9B;
            --accent-primary: #2C2C2C;
            --accent-gold: #C4A962;
            --accent-gold-light: rgba(196, 169, 98, 0.15);
            --accent-success: #4A9B7F;
            --accent-warning: #E5A84B;
            --accent-danger: #D4574E;
            --accent-blue: #5B8DEF;
            --accent-purple: #8B5CF6;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
            background: var(--bg-body);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ===== 상단 헤더 ===== */
        .top-header {
            height: 56px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 24px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 16px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-gold), #B8975A);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            font-weight: bold;
        }

        .logo span { color: var(--accent-gold); }

        .preset-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-selector:hover {
            border-color: var(--accent-gold);
        }

        .preset-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .preset-dot.free { background: var(--accent-success); }
        .preset-dot.standard { background: var(--accent-gold); }
        .preset-dot.detailed { background: var(--accent-purple); }

        .header-center { flex: 1; }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-light);
            background: var(--bg-card);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            font-size: 14px;
        }

        .btn-icon:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* ===== 메인 레이아웃 ===== */
        .main-layout {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* ===== 사이드바 ===== */
        .sidebar {
            width: 570px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        /* Phase 탭 */
        .phase-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-light);
            background: var(--bg-body);
        }

        .phase-tab {
            flex: 1;
            padding: 14px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: inherit;
            font-size: 12px;
            color: var(--text-muted);
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .phase-tab:hover:not(:disabled) {
            color: var(--text-secondary);
            background: var(--bg-card);
        }

        .phase-tab.active {
            color: var(--accent-gold);
            background: var(--bg-card);
            border-bottom-color: var(--accent-gold);
        }

        .phase-tab:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .phase-num {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
        }

        .phase-tab.active .phase-num {
            background: var(--accent-gold);
            color: white;
        }

        .phase-tab.completed .phase-num {
            background: var(--accent-success);
            color: white;
        }

        .phase-name {
            font-weight: 500;
        }

        /* Phase 콘텐츠 */
        .phase-content {
            display: none;
        }

        .phase-content.active {
            display: block;
        }

        .phase-description {
            padding: 16px;
            background: var(--accent-gold-light);
            border-bottom: 1px solid var(--border-light);
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .phase-description strong {
            color: var(--accent-gold);
        }

        /* 페르소나 칩 */
        .persona-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            background: var(--bg-body);
            border-radius: var(--radius-sm);
            min-height: 60px;
        }

        .persona-chip {
            padding: 8px 14px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .persona-chip .avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gold);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
        }

        .empty-personas, .empty-target {
            color: var(--text-muted);
            font-size: 12px;
            text-align: center;
            padding: 16px;
        }

        .validation-summary {
            padding: 12px;
            background: var(--accent-success-light, rgba(74, 155, 127, 0.1));
            border-radius: var(--radius-md);
            border: 1px solid rgba(74, 155, 127, 0.3);
        }

        .validation-summary-title {
            font-weight: 600;
            color: var(--accent-success);
            margin-bottom: 8px;
        }

        .validation-items {
            margin: 0;
            padding-left: 20px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .validation-items li {
            margin-bottom: 4px;
        }

        /* 에이전트 팀 */
        .agent-team-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .agent-chip {
            padding: 6px 10px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Coming Soon 배지 */
        .badge-coming {
            font-size: 9px;
            padding: 2px 6px;
            background: var(--accent-purple);
            color: white;
            border-radius: 8px;
            margin-left: 6px;
        }

        .badge-muted {
            font-size: 10px;
            color: var(--text-muted);
        }

        .input-card.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .context-source {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .context-icon {
            font-size: 18px;
        }

        /* 검증 기준 */
        .validation-criteria {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .criteria-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-body);
            border-radius: var(--radius-sm);
            font-size: 12px;
            cursor: pointer;
        }

        .criteria-item:hover {
            background: var(--bg-card);
        }

        .criteria-item input[type="checkbox"] {
            accent-color: var(--accent-gold);
        }

        /* Phase 인디케이터 */
        .phase-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 8px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-light);
        }

        .phase-indicator-item {
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.4;
        }

        .phase-indicator-item.active {
            opacity: 1;
        }

        .phase-indicator-item.completed {
            opacity: 1;
        }

        .phase-indicator-badge {
            font-size: 9px;
            font-weight: 600;
            padding: 2px 8px;
            background: var(--bg-body);
            border-radius: 10px;
            color: var(--text-muted);
        }

        .phase-indicator-item.active .phase-indicator-badge {
            background: var(--accent-gold);
            color: white;
        }

        .phase-indicator-item.completed .phase-indicator-badge {
            background: var(--accent-success);
            color: white;
        }

        .phase-indicator-title {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .phase-indicator-arrow {
            color: var(--text-muted);
            font-size: 14px;
        }

        /* Phase별 파이프라인 - 통합되어 항상 표시 */

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-title {
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .input-section {
            margin-bottom: 20px;
        }

        .input-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .input-card {
            padding: 12px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
        }

        .input-card.filled {
            border-left: 3px solid var(--accent-success);
        }

        .input-textarea {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 13px;
            resize: none;
            outline: none;
            line-height: 1.5;
            font-family: inherit;
        }

        .input-textarea::placeholder {
            color: var(--text-muted);
        }

        /* 장르/태그 선택 */
        .genre-count {
            font-weight: 400;
            color: var(--accent-gold);
            font-size: 10px;
        }

        .filter-subsection {
            margin-bottom: 12px;
        }

        .filter-subsection:last-child {
            margin-bottom: 0;
        }

        .filter-sublabel {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .tag-reset-btn {
            font-size: 9px;
            color: var(--text-muted);
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: inherit;
        }

        .tag-reset-btn:hover {
            background: rgba(212, 87, 78, 0.1);
            color: var(--accent-danger);
        }

        .genre-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 28px;
            overflow: hidden;
        }

        .genre-grid.expanded {
            max-height: none;
        }

        .genre-expanded {
            margin-top: 6px;
        }

        .genre-btn {
            padding: 4px 10px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            font-family: inherit;
            white-space: nowrap;
        }

        .genre-btn:hover {
            border-color: var(--accent-gold);
            background: var(--accent-gold-light);
        }

        .genre-btn.selected {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }

        .filter-expand-btn {
            padding: 4px 10px;
            background: var(--bg-body);
            border: 1px dashed var(--border-medium);
            border-radius: 12px;
            font-size: 10px;
            color: var(--text-muted);
            cursor: pointer;
            font-family: inherit;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .filter-expand-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .ref-count-badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--accent-gold);
            color: white;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
        }

        /* 선택된 게임 목록 */
        .selected-games-list {
            margin-bottom: 12px;
            padding: 10px;
            background: var(--accent-gold-light);
            border: 1px solid var(--accent-gold);
            border-radius: var(--radius-sm);
        }

        .selected-games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-gold);
        }

        .selected-games-clear {
            padding: 2px 8px;
            background: transparent;
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            font-size: 9px;
            color: var(--accent-gold);
            cursor: pointer;
            font-family: inherit;
        }

        .selected-games-clear:hover {
            background: var(--accent-gold);
            color: white;
        }

        .selected-games-items {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-game-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 14px;
            font-size: 11px;
            color: var(--text-primary);
        }

        .selected-game-remove {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-danger);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .selected-game-remove:hover {
            background: #c0392b;
        }

        /* Reference 검색 */
        .ref-search-wrapper {
            position: relative;
            margin-bottom: 12px;
        }

        .ref-search-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 12px;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .ref-search-input:focus {
            border-color: var(--accent-gold);
        }

        .ref-search-input::placeholder {
            color: var(--text-muted);
        }

        .ref-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-top: none;
            border-radius: 0 0 var(--radius-sm) var(--radius-sm);
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: var(--shadow-md);
        }

        .ref-search-results.active {
            display: block;
        }

        .ref-search-item {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid var(--border-light);
            transition: background 0.15s;
        }

        .ref-search-item:last-child {
            border-bottom: none;
        }

        .ref-search-item:hover {
            background: var(--accent-gold-light);
        }

        .ref-search-item.added {
            background: rgba(74, 155, 127, 0.1);
        }

        .ref-search-thumb {
            width: 40px;
            height: 40px;
            background: var(--bg-body);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .ref-search-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ref-search-info {
            flex: 1;
            min-width: 0;
        }

        .ref-search-name {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ref-search-meta {
            font-size: 10px;
            color: var(--text-muted);
        }

        .ref-search-add {
            font-size: 16px;
            color: var(--accent-gold);
            font-weight: bold;
        }

        .ref-search-loading {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 11px;
        }

        .ref-divider {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            font-size: 10px;
            color: var(--text-muted);
        }

        .ref-divider::before,
        .ref-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-light);
        }

        /* 태그 필터 */
        .tag-filter-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 28px;
            overflow: hidden;
        }

        .tag-filter-list.expanded {
            max-height: none;
        }

        .tag-filter-expanded {
            margin-top: 6px;
        }

        .tag-filter-btn {
            padding: 4px 10px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            font-size: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: inherit;
            transition: all 0.15s;
        }

        .tag-filter-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .tag-filter-btn.selected {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
            position: relative;
            padding-right: 24px;
        }

        .tag-filter-btn.selected .tag-remove {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            transition: all 0.15s;
        }

        .tag-filter-btn.selected .tag-remove:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Reference 게임 */
        .ref-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .ref-sort-tabs {
            display: flex;
            gap: 4px;
        }

        .ref-sort-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid var(--border-light);
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .ref-sort-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .ref-sort-btn.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: white;
        }

        .ref-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .ref-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ref-item:hover {
            border-color: var(--accent-gold);
        }

        .ref-item.selected {
            border-color: var(--accent-success);
            background: rgba(74, 155, 127, 0.05);
        }

        .ref-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-medium);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 12px;
            color: white;
        }

        .ref-item.selected .ref-checkbox {
            background: var(--accent-success);
            border-color: var(--accent-success);
        }

        .ref-info { flex: 1; min-width: 0; }

        .ref-name {
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ref-meta {
            font-size: 10px;
            color: var(--text-muted);
            display: flex;
            gap: 8px;
        }

        .ref-loading {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 12px;
        }

        .ref-loading .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-light);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== 메인 영역 ===== */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 파이프라인 */
        .pipeline-header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 16px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .pipeline-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pipeline-divider {
            color: var(--text-muted);
            font-size: 12px;
            padding: 0 4px;
        }

        .pipeline-steps {
            display: flex;
            align-items: center;
        }

        .pipeline-phase1 {
            flex: 3;
        }

        .pipeline-phase2 {
            flex: 1;
            width: 100%;
        }

        .pipeline-phase3 {
            flex: 2;
        }

        /* Phase 3 단계 스타일 (둥근 모양) */
        .phase3-step {
            border-radius: var(--radius-md) !important;
            margin-left: 4px;
            border: 1px dashed var(--border-medium) !important;
            background: var(--bg-card) !important;
        }

        .phase3-step.completed {
            border-style: solid !important;
            border-color: var(--accent-success) !important;
        }

        .phase3-step.active {
            border-style: solid !important;
            border-color: var(--accent-gold) !important;
        }

        .pipeline-step {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pipeline-step:first-child { border-radius: var(--radius-md) 0 0 var(--radius-md); }
        .pipeline-step:last-child { border-radius: 0 var(--radius-md) var(--radius-md) 0; }
        .pipeline-step:not(:last-child) { border-right: none; }

        .pipeline-step.completed {
            background: linear-gradient(135deg, rgba(74, 155, 127, 0.1), rgba(74, 155, 127, 0.05));
            border-color: rgba(74, 155, 127, 0.4);
        }

        .pipeline-step.active {
            background: linear-gradient(135deg, rgba(196, 169, 98, 0.15), rgba(196, 169, 98, 0.08));
            border-color: var(--accent-gold);
            border-right: 1px solid var(--accent-gold);
            z-index: 2;
        }
        
        /* active 단계가 마지막이 아닐 때도 오른쪽 마감 처리 */
        .pipeline-step.active:not(:last-child) {
            border-right: 1px solid var(--accent-gold);
            border-radius: var(--radius-md);
            margin-right: -1px;
        }

        .pipeline-step.pending {
            opacity: 0.5;
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            background: var(--bg-card);
            border: 2px solid var(--border-medium);
            flex-shrink: 0;
        }

        .pipeline-step.completed .step-icon { 
            background: var(--accent-success); 
            color: white; 
            border: none;
        }
        .pipeline-step.active .step-icon { 
            background: var(--accent-gold); 
            color: white; 
            border: none;
        }

        .step-info { display: flex; flex-direction: column; gap: 1px; }
        .step-label { font-size: 13px; font-weight: 600; }
        .step-desc { font-size: 10px; color: var(--text-muted); }
        .pipeline-step.completed .step-desc { color: var(--accent-success); }
        .pipeline-step.active .step-desc { color: var(--accent-gold); }

        .pipeline-step.viewing {
            box-shadow: 0 0 0 2px var(--accent-blue);
        }

        .pipeline-step.completed:hover,
        .pipeline-step.active:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* 메인 콘텐츠 */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .content-area {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* 스텝 뷰 */
        .step-view {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .step-view.active {
            display: flex;
        }

        .step-view-header {
            padding: 24px 32px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
        }

        .step-view-title {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .step-view-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent-gold), #B8975A);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
        }

        .step-view-title h2 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .step-view-title p {
            font-size: 13px;
            color: var(--text-muted);
        }

        .step-view-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 32px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .step-main-content {
            flex: 1;
        }

        .step-log-panel {
            background: var(--bg-body);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            margin-top: 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .step-log-header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: transparent;
            border-bottom: 1px solid #333;
            cursor: pointer;
        }

        .step-log-header:hover {
            background: rgba(0,0,0,0.02);
        }

        .step-log-title {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .step-log-toggle {
            font-size: 10px;
            color: var(--text-muted);
            transition: transform 0.2s;
        }

        .step-log-panel.collapsed .step-log-toggle {
            transform: rotate(-90deg);
        }

        .step-log-content {
            max-height: 200px;
            overflow-y: auto;
            padding: 0 16px 16px;
            font-family: 'Pretendard', sans-serif;
            font-size: 12px;
            line-height: 1.6;
            max-height: 250px;
        }

        .step-log-panel.collapsed .step-log-content {
            display: none;
        }

        .step-log-empty {
            color: var(--text-muted);
            text-align: center;
            padding: 20px;
            font-size: 12px;
        }

        /* 개선된 로그 엔트리 스타일 */
        .step-log-content .log-entry {
            display: flex;
            gap: 12px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: var(--radius-sm);
            margin-bottom: 6px;
            border-left: 3px solid var(--border-light);
        }

        .step-log-content .log-entry.api {
            border-left-color: var(--accent-blue);
        }

        .step-log-content .log-entry.success {
            border-left-color: var(--accent-success);
        }

        .step-log-content .log-entry.error {
            border-left-color: var(--accent-danger);
        }

        .step-log-content .log-entry.info {
            border-left-color: var(--accent-gold);
        }

        .step-log-content .log-time {
            font-size: 10px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
        }

        .step-log-content .log-message {
            flex: 1;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .step-log-content .log-icon {
            font-size: 11px;
            width: 16px;
            text-align: center;
        }

        .step-log-content .log-entry.success .log-icon {
            color: var(--accent-success);
        }

        .step-log-content .log-entry.error .log-icon {
            color: var(--accent-danger);
        }

        .step-log-content .log-entry.api .log-icon {
            color: var(--accent-blue);
        }

        /* 대기 상태 */
        .step-pending {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 300px;
            color: var(--text-muted);
            text-align: center;
        }

        .step-pending-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-body);
            border: 2px dashed var(--border-medium);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: 700;
            color: var(--border-medium);
            margin-bottom: 16px;
        }

        .step-pending-text {
            font-size: 14px;
        }

        /* 진행중 상태 */
        .step-running {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 300px;
        }

        .step-running .spinner-lg {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-light);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .step-running-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* 크리에이팅 결과 */
        .creating-result {
            padding: 24px;
            max-height: 100%;
            overflow-y: auto;
        }

        .creating-result h2 {
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .agent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .agent-card {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 400px;
        }

        .agent-card-header {
            padding: 12px 16px;
            background: var(--bg-body);
            font-weight: 600;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
        }

        .agent-card-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .agent-section {
            margin-bottom: 12px;
        }

        .agent-section:last-child {
            margin-bottom: 0;
        }

        .agent-section strong {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .agent-section p {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }

        .agent-section ul {
            margin: 0;
            padding-left: 20px;
            font-size: 14px;
        }

        .agent-section li {
            margin-bottom: 4px;
            line-height: 1.6;
        }

        .agent-section li strong {
            display: inline;
            color: var(--text-primary);
            font-size: inherit;
        }

        .nested-content {
            font-size: 13px;
            line-height: 1.6;
            padding: 8px 12px;
            background: var(--bg-body);
            border-radius: var(--radius-sm);
            margin-top: 4px;
        }

        .nested-content strong {
            color: var(--text-primary);
            display: inline;
            font-size: inherit;
        }

        .synthesis-card {
            background: linear-gradient(135deg, var(--accent-gold-light), rgba(196, 169, 98, 0.05));
            border: 1px solid var(--accent-gold);
            border-radius: var(--radius-md);
            overflow: hidden;
            max-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .synthesis-header {
            padding: 12px 16px;
            background: rgba(196, 169, 98, 0.1);
            font-weight: 600;
            color: var(--accent-gold);
            flex-shrink: 0;
        }

        .synthesis-body {
            padding: 16px;
            font-size: 14px;
            line-height: 1.7;
            white-space: pre-wrap;
            overflow-y: auto;
            flex: 1;
        }

        /* 초기 상태 */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
        }

        .empty-icon {
            width: 80px;
            height: 80px;
            background: var(--bg-body);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 16px;
            border: 2px dashed var(--border-medium);
        }

        .empty-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-desc {
            font-size: 13px;
            max-width: 300px;
        }

        /* 결과 카드 */
        .result-section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-icon {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .section-icon.review { background: linear-gradient(135deg, #818cf8, #6366f1); }
        .section-icon.persona { background: linear-gradient(135deg, #34d399, #10b981); }
        .section-icon.risk { background: linear-gradient(135deg, #fbbf24, #f59e0b); }

        .section-title h2 {
            font-size: 16px;
            font-weight: 700;
        }

        .section-count {
            font-size: 12px;
            color: var(--text-muted);
        }

        .section-actions {
            display: flex;
            gap: 8px;
        }

        .btn-sm {
            padding: 6px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .btn-sm:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* 리뷰 태그 분포 */
        .tag-distribution {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .dist-item {
            padding: 14px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
        }

        .dist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .dist-label {
            font-size: 12px;
            font-weight: 600;
        }

        .dist-value {
            font-size: 12px;
            font-weight: 700;
        }

        .dist-value.pain { color: var(--accent-danger); }
        .dist-value.delight { color: var(--accent-success); }

        .dist-bar {
            height: 6px;
            background: var(--bg-body);
            border-radius: 3px;
            overflow: hidden;
        }

        .dist-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .dist-bar-fill.pain { background: var(--accent-danger); }
        .dist-bar-fill.delight { background: var(--accent-success); }

        /* 페르소나 카드 */
        .persona-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }

        .persona-card {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: all 0.2s;
        }

        .persona-card:hover {
            border-color: var(--accent-gold);
            box-shadow: var(--shadow-md);
        }

        .persona-card.top {
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 1px var(--accent-gold);
        }

        .persona-header {
            padding: 16px;
            background: var(--bg-body);
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .persona-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), #B8975A);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        .persona-meta { flex: 1; }

        .persona-name {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .persona-type {
            font-size: 11px;
            color: var(--text-muted);
        }

        .persona-badge {
            padding: 4px 10px;
            background: var(--accent-gold-light);
            border: 1px solid var(--accent-gold);
            border-radius: 12px;
            font-size: 10px;
            color: var(--accent-gold);
            font-weight: 600;
        }

        .persona-body {
            padding: 16px;
        }

        .persona-section {
            margin-bottom: 12px;
        }

        .persona-section:last-child { margin-bottom: 0; }

        .persona-section-title {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .persona-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .persona-tag {
            padding: 4px 8px;
            background: var(--bg-body);
            border-radius: 4px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .persona-tag.goal { border-left: 2px solid var(--accent-success); }
        .persona-tag.pain { border-left: 2px solid var(--accent-danger); }
        .persona-tag.trigger { border-left: 2px solid var(--accent-warning); }

        /* 리스크 목록 */
        .risk-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .risk-item {
            padding: 14px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .risk-severity {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-top: 5px;
            flex-shrink: 0;
        }

        .risk-severity.high { background: var(--accent-danger); }
        .risk-severity.medium { background: var(--accent-warning); }
        .risk-severity.low { background: var(--accent-success); }

        .risk-content { flex: 1; }

        .risk-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .risk-category {
            padding: 2px 8px;
            background: var(--bg-body);
            border-radius: 4px;
            font-size: 10px;
            color: var(--text-muted);
        }

        .risk-mitigation {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* 리뷰 수집 결과 */
        .review-summary {
            max-width: 600px;
        }

        .summary-stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .summary-stat {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 20px;
            text-align: center;
        }

        .summary-stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-gold);
            margin-bottom: 4px;
        }

        .summary-stat-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .review-game-list {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 16px;
        }

        .review-game-list h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .review-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-light);
        }

        .review-game-item:last-child {
            border-bottom: none;
        }

        .review-game-name {
            font-size: 13px;
            font-weight: 500;
        }

        .review-game-count {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* 리뷰 결과 상세 */
        .review-game-stats {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
        }

        .review-count {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .review-positive {
            color: var(--accent-success);
        }

        .review-negative {
            color: var(--accent-danger);
        }

        .review-rate {
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 11px;
        }

        .review-rate.good {
            background: rgba(74, 155, 127, 0.15);
            color: var(--accent-success);
        }

        .review-rate.mixed {
            background: rgba(229, 168, 75, 0.15);
            color: var(--accent-warning);
        }

        .review-rate.bad {
            background: rgba(212, 87, 78, 0.15);
            color: var(--accent-danger);
        }

        .review-samples {
            margin-top: 24px;
        }

        .review-samples h4 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        .review-sample-item {
            padding: 12px;
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
            border-left: 3px solid;
        }

        .review-sample-item.positive {
            background: rgba(74, 155, 127, 0.08);
            border-color: var(--accent-success);
        }

        .review-sample-item.negative {
            background: rgba(212, 87, 78, 0.08);
            border-color: var(--accent-danger);
        }

        .review-sample-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .review-game-tag {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-light);
            border-radius: 4px;
            color: var(--text-muted);
        }

        .review-sample-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .summary-stat.positive .summary-stat-value {
            color: var(--accent-success);
        }

        .summary-stat.negative .summary-stat-value {
            color: var(--accent-danger);
        }

        /* 태깅 결과 상세 */
        .tag-result {
            max-width: 800px;
        }

        .tag-summary-box {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 24px;
        }

        .tag-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .tag-summary-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        .tag-summary-count {
            font-size: 12px;
            color: var(--text-muted);
            background: var(--bg-light);
            padding: 4px 10px;
            border-radius: 12px;
        }

        .tag-summary-text {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0;
        }

        .tag-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .tag-section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-light);
        }

        .pain-section .tag-section-title {
            color: var(--accent-danger);
            border-color: var(--accent-danger);
        }

        .delight-section .tag-section-title {
            color: var(--accent-success);
            border-color: var(--accent-success);
        }

        .dist-description {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
            padding-left: 4px;
        }

        /* 페르소나 결과 상세 */
        .persona-result {
            max-width: 1000px;
        }

        .persona-reasoning-box {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-light));
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 24px;
        }

        .persona-reasoning-box h4 {
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        .persona-reasoning-box p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0 0 8px;
        }

        .persona-card.primary {
            border: 2px solid var(--primary-color);
        }

        .persona-badges {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-end;
        }

        .persona-badge.primary {
            background: var(--primary-color);
            color: white;
        }

        .persona-fit {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .persona-fit.excellent {
            background: rgba(74, 155, 127, 0.15);
            color: var(--accent-success);
        }

        .persona-fit.good {
            background: rgba(229, 168, 75, 0.15);
            color: var(--accent-warning);
        }

        .persona-fit.fair {
            background: rgba(200, 150, 80, 0.15);
            color: #c89650;
        }

        .persona-fit.low {
            background: rgba(212, 87, 78, 0.15);
            color: var(--accent-danger);
        }

        .persona-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 12px 0;
            padding: 10px;
            background: var(--bg-light);
            border-radius: var(--radius-sm);
        }

        /* 리스크 결과 상세 */
        .risk-result {
            max-width: 800px;
        }

        .risk-summary-box {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 24px;
        }

        .risk-summary-box h4 {
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .risk-summary-box p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0 0 16px;
        }

        .risk-counts {
            display: flex;
            gap: 16px;
        }

        .risk-count {
            font-size: 13px;
            font-weight: 600;
        }

        .risk-count.high { color: var(--accent-danger); }
        .risk-count.medium { color: var(--accent-warning); }
        .risk-count.low { color: var(--accent-success); }

        .risk-item.high {
            background: rgba(212, 87, 78, 0.05);
        }

        .risk-item.medium {
            background: rgba(229, 168, 75, 0.05);
        }

        .risk-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .risk-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .risk-affected {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .risk-affected-label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .risk-affected-persona {
            font-size: 11px;
            padding: 2px 8px;
            background: var(--bg-light);
            border-radius: 10px;
            color: var(--text-secondary);
        }

        .mitigation-label {
            font-weight: 600;
            margin-right: 4px;
        }

        /* 리포트 결과 상세 */
        .report-full {
            max-width: 900px;
        }

        .report-header-section {
            display: flex;
            gap: 40px;
            align-items: center;
            margin-bottom: 32px;
            padding-bottom: 32px;
            border-bottom: 1px solid var(--border-light);
        }

        .report-header-section .report-overview {
            flex: 1;
            margin-bottom: 0;
        }

        .report-executive-summary {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-light));
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 24px;
            margin-bottom: 32px;
        }

        .report-executive-summary h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .report-executive-summary p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.7;
            margin: 0;
        }

        .report-swot {
            margin-bottom: 32px;
        }

        .report-swot h3 {
            font-size: 16px;
            margin-bottom: 16px;
        }

        .swot-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .swot-item {
            padding: 20px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-light);
        }

        .swot-item h4 {
            font-size: 13px;
            margin-bottom: 12px;
        }

        .swot-item ul {
            margin: 0;
            padding-left: 20px;
        }

        .swot-item li {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 6px;
        }

        .swot-item.strengths {
            background: rgba(74, 155, 127, 0.08);
        }

        .swot-item.strengths h4 {
            color: var(--accent-success);
        }

        .swot-item.weaknesses {
            background: rgba(212, 87, 78, 0.08);
        }

        .swot-item.weaknesses h4 {
            color: var(--accent-danger);
        }

        .swot-item.opportunities {
            background: rgba(79, 140, 191, 0.08);
        }

        .swot-item.opportunities h4 {
            color: var(--primary-color);
        }

        .swot-item.threats {
            background: rgba(229, 168, 75, 0.08);
        }

        .swot-item.threats h4 {
            color: var(--accent-warning);
        }

        .report-next-steps {
            margin-bottom: 32px;
        }

        .report-next-steps h3 {
            font-size: 16px;
            margin-bottom: 16px;
        }

        .next-steps-list {
            padding-left: 24px;
            margin: 0;
        }

        .next-steps-list li {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: 10px;
            padding-left: 8px;
        }

        .report-success-factors {
            margin-bottom: 32px;
        }

        .report-success-factors h3 {
            font-size: 16px;
            margin-bottom: 16px;
        }

        .success-factors-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .success-factor {
            padding: 10px 16px;
            background: var(--primary-color);
            color: white;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        /* 리포트 결과 */
        .report-summary {
            max-width: 500px;
            margin: 0 auto;
            text-align: center;
        }

        .report-score {
            margin-bottom: 32px;
        }

        .report-score-circle {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            border: 4px solid;
        }

        .report-score-circle.success {
            border-color: var(--accent-success);
            background: rgba(74, 155, 127, 0.1);
        }

        .report-score-circle.warning {
            border-color: var(--accent-warning);
            background: rgba(229, 168, 75, 0.1);
        }

        .report-score-circle.danger {
            border-color: var(--accent-danger);
            background: rgba(212, 87, 78, 0.1);
        }

        .report-score-value {
            font-size: 48px;
            font-weight: 700;
            line-height: 1;
        }

        .report-score-circle.success .report-score-value { color: var(--accent-success); }
        .report-score-circle.warning .report-score-value { color: var(--accent-warning); }
        .report-score-circle.danger .report-score-value { color: var(--accent-danger); }

        .report-score-label {
            font-size: 14px;
            color: var(--text-muted);
        }

        .report-recommendation {
            font-size: 18px;
            font-weight: 700;
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
        }

        .report-recommendation.success {
            background: rgba(74, 155, 127, 0.15);
            color: var(--accent-success);
        }

        .report-recommendation.warning {
            background: rgba(229, 168, 75, 0.15);
            color: var(--accent-warning);
        }

        .report-recommendation.danger {
            background: rgba(212, 87, 78, 0.15);
            color: var(--accent-danger);
        }

        .report-overview {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .report-stat {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 16px;
            text-align: left;
        }

        .report-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .report-stat-value {
            font-size: 16px;
            font-weight: 600;
        }

        .report-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        /* ===== 우측 패널 ===== */
        .intervention-panel {
            width: 340px;
            background: var(--bg-sidebar);
            border-left: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
            transition: width 0.3s ease, margin-right 0.3s ease;
        }

        .intervention-panel.collapsed {
            width: 0;
            overflow: hidden;
            border-left: none;
        }

        .panel-toggle {
            position: absolute;
            left: -32px;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 64px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-right: none;
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .panel-toggle:hover {
            background: var(--bg-body);
            color: var(--accent-gold);
        }

        .intervention-panel.collapsed .panel-toggle {
            left: -32px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
        }

        .panel-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-header h3 {
            font-size: 14px;
            font-weight: 600;
            flex: 1;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .intervention-card {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            margin-bottom: 16px;
            overflow: hidden;
        }

        .intervention-header {
            padding: 12px 16px;
            background: var(--bg-body);
            border-bottom: 1px solid var(--border-light);
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .intervention-body {
            padding: 16px;
        }

        .context-input {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            resize: vertical;
            outline: none;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        .context-input:focus {
            border-color: var(--accent-gold);
        }

        .context-input::placeholder {
            color: var(--text-muted);
        }

        .intervention-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn {
            padding: 10px 16px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            border: none;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-gold), #B8975A);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(196, 169, 98, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid var(--border-light);
            color: var(--text-secondary);
        }

        .btn-ghost:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* 빠른 개입 버튼 */
        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .quick-btn {
            padding: 10px 14px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-family: inherit;
        }

        .quick-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: var(--accent-gold-light);
        }

        /* 진행 상태 */
        .progress-card {
            padding: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            margin-bottom: 16px;
        }

        .progress-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-bar {
            height: 8px;
            background: var(--bg-body);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-success));
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .progress-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .progress-stat {
            text-align: center;
            padding: 10px;
            background: var(--bg-body);
            border-radius: var(--radius-sm);
        }

        .progress-stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .progress-stat-label {
            font-size: 10px;
            color: var(--text-muted);
        }

        /* 히스토리 */
        .history-item {
            padding: 10px 12px;
            background: var(--bg-body);
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
            font-size: 12px;
        }

        .history-time {
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .history-text {
            color: var(--text-secondary);
        }

        .history-text strong {
            color: var(--text-primary);
        }

        /* ===== 하단 바 ===== */
        .bottom-bar {
            padding: 14px 32px;
            background: var(--bg-card);
            border-top: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .footer-info {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .footer-actions {
            display: flex;
            gap: 10px;
        }

        .footer-stats {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
            margin-right: 20px;
        }

        .footer-stat {
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-muted);
            padding: 4px 10px;
            background: var(--bg-light);
            border-radius: 4px;
        }

        .footer-stat.footer-cost {
            color: var(--primary-color);
            font-weight: 600;
        }

        .btn-lg {
            padding: 12px 20px;
            font-size: 13px;
        }

        .btn-secondary {
            background: var(--bg-body);
            border: 1px solid var(--border-medium);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            background: var(--border-light);
        }

        .btn-success {
            background: var(--accent-success);
            color: white;
        }

        .btn-success:hover {
            background: #3d8b6e;
        }

        /* ===== 상태바 ===== */
        .status-bar {
            height: 28px;
            background: #D4C8A8;
            border-top: 1px solid #C4B898;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 11px;
            color: #4A4A4A;
            flex-shrink: 0;
        }

        .status-left, .status-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .status-item:hover {
            color: #2A2A2A;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-dot.connected { background: #4A9B7F; }
        .status-dot.disconnected { background: #D4574E; }
        .status-dot.warning { background: #E5A84B; }

        /* ===== 모달 ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            width: 90%;
            max-width: 520px;
            box-shadow: var(--shadow-md);
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .modal-header h3 {
            font-size: 16px;
            font-weight: 700;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: var(--radius-sm);
            font-size: 18px;
        }

        .modal-close:hover {
            background: var(--bg-body);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-light);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-shrink: 0;
        }

        /* 설정 모달 */
        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 13px;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
        }

        .setting-input:focus {
            border-color: var(--accent-gold);
        }

        .setting-input::placeholder {
            color: var(--text-muted);
        }

        .setting-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin-top: 6px;
        }

        .api-status.valid { color: var(--accent-success); }
        .api-status.invalid { color: var(--accent-danger); }

        /* 프리셋 옵션 */
        .preset-option {
            padding: 14px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-option:hover {
            border-color: var(--accent-gold);
        }

        .preset-option.active {
            border-color: var(--accent-gold);
            background: var(--accent-gold-light);
        }

        .preset-option-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 4px;
        }

        .preset-option-name {
            font-weight: 600;
            font-size: 13px;
        }

        .preset-option-desc {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* 되돌림 확인 모달 */
        .rollback-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .rollback-option {
            padding: 16px;
            background: var(--bg-body);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .rollback-option:hover {
            border-color: var(--accent-gold);
        }

        .rollback-option h4 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .rollback-option p {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* 토스트 */
        .toast-container {
            position: fixed;
            bottom: 60px;
            right: 24px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            padding: 12px 16px;
            background: var(--text-primary);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 12px;
            box-shadow: var(--shadow-md);
            animation: slideIn 0.3s ease;
        }

        .toast.success { background: var(--accent-success); }
        .toast.error { background: var(--accent-danger); }
        .toast.warning { background: var(--accent-warning); }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* 로그 패널 */
        .log-panel {
            position: fixed;
            bottom: 28px;
            left: 0;
            right: 0;
            background: #1a1a1a;
            border-top: 1px solid #333;
            z-index: 100;
            transition: height 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .log-panel.collapsed {
            height: 36px;
        }

        .log-panel.expanded {
            height: 240px;
        }

        .log-header {
            height: 36px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #222;
            border-bottom: 1px solid #333;
            cursor: pointer;
            flex-shrink: 0;
        }

        .log-header:hover {
            background: #2a2a2a;
        }

        .log-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-toggle-icon {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s;
        }

        .log-panel.collapsed .log-toggle-icon {
            transform: rotate(180deg);
        }

        .log-title {
            font-size: 12px;
            font-weight: 600;
            color: #ccc;
        }

        .log-badge {
            padding: 2px 8px;
            background: var(--border-light);
            border-radius: 10px;
            font-size: 10px;
            color: var(--text-muted);
            margin-left: 8px;
        }

        .log-badge.has-logs {
            background: var(--accent-gold-light);
            color: var(--accent-gold);
        }

        .log-clear-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 10px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
        }

        .log-clear-btn:hover {
            border-color: #666;
            color: #ccc;
        }

        .log-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-panel.collapsed .log-content {
            display: none;
        }

        .log-empty {
            color: #555;
            text-align: center;
            padding: 40px;
        }

        .log-entry {
            display: flex;
            gap: 12px;
            padding: 4px 0;
            border-bottom: 1px solid #2a2a2a;
        }

        .log-time {
            color: #555;
            flex-shrink: 0;
            width: 70px;
        }

        .log-type {
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            flex-shrink: 0;
            width: 50px;
            text-align: center;
        }

        .log-type.info { background: #2563eb22; color: #60a5fa; }
        .log-type.step { background: #c4a96222; color: #c4a962; }
        .log-type.api { background: #8b5cf622; color: #a78bfa; }
        .log-type.success { background: #4a9b7f22; color: #4ade80; }
        .log-type.error { background: #d4574e22; color: #f87171; }
        .log-type.context { background: #06b6d422; color: #22d3ee; }

        .log-message {
            color: #ccc;
            flex: 1;
            word-break: break-word;
        }

        .log-message code {
            background: #333;
            padding: 1px 4px;
            border-radius: 3px;
            color: #f472b6;
        }

        .log-message .highlight {
            color: #fbbf24;
        }

        .log-detail {
            margin-top: 4px;
            padding: 8px;
            background: #252525;
            border-radius: 4px;
            color: #888;
            font-size: 10px;
            white-space: pre-wrap;
            max-height: 100px;
            overflow-y: auto;
        }

        /* 검증 결과 스타일 - 풀 레이아웃 */
        .validation-result-full {
            padding: 24px;
            max-height: 100%;
            overflow-y: auto;
        }

        .validation-header {
            margin-bottom: 24px;
        }

        .validation-header h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .validation-header .score-display {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            padding: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
        }

        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dark, #b8860b));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 700;
            color: var(--bg-body);
            flex-shrink: 0;
        }

        .score-info {
            flex: 1;
        }

        .recommendation {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .verdict-text {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0;
        }

        .validation-body {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 24px;
        }

        .validation-details h3 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .validation-categories {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .validation-category {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 16px;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .category-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .category-score {
            font-size: 13px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .category-score.good {
            background: rgba(74, 155, 127, 0.15);
            color: var(--accent-success);
        }

        .category-score.warning {
            background: rgba(229, 168, 75, 0.15);
            color: var(--accent-warning);
        }

        .category-score.danger {
            background: rgba(212, 87, 78, 0.15);
            color: var(--accent-danger);
        }

        .category-issues,
        .category-suggestions {
            margin-top: 12px;
        }

        .issue-label,
        .suggestion-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            display: block;
            margin-bottom: 8px;
        }

        .category-issues ul,
        .category-suggestions ul {
            margin: 0;
            padding-left: 18px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .category-issues li,
        .category-suggestions li {
            margin-bottom: 4px;
            line-height: 1.5;
        }

        .category-suggestions ul {
            color: var(--accent-success);
        }

        /* 우측 요약 패널 */
        .validation-summary-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .summary-section {
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 16px;
        }

        .summary-section h4 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .summary-section ul,
        .summary-section ol {
            margin: 0;
            padding-left: 18px;
        }

        .summary-section li {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 6px;
        }

        .summary-section.strengths {
            border-left: 3px solid var(--accent-success);
        }

        .summary-section.risks {
            border-left: 3px solid var(--accent-warning);
        }

        .summary-section.next-steps {
            border-left: 3px solid var(--accent-blue);
        }

        /* 레거시 호환 */
        .validation-result {
            max-width: 700px;
            margin: 0 auto;
            padding: 24px;
        }
    </style>
</head>
<body>
    <!-- 상단 헤더 -->
    <header class="top-header">
        <div class="logo">
            <div class="logo-icon">VV</div>
            Vibe<span>Validator</span>
        </div>

        <div class="preset-selector" onclick="openPresetModal()">
            <span class="preset-dot standard" id="presetDot"></span>
            <span id="currentPreset">Standard</span>
            <span style="font-size: 10px; opacity: 0.5;">▼</span>
        </div>

        <div class="header-center"></div>

        <div class="header-right">
            <button class="btn-icon" onclick="openSettingsModal()" title="설정">⚙</button>
        </div>
    </header>

    <!-- 메인 레이아웃 -->
    <div class="main-layout">
        <!-- 사이드바 -->
        <aside class="sidebar">
            <!-- Phase 탭 -->
            <div class="phase-tabs">
                <button class="phase-tab active" data-phase="1" onclick="switchPhase(1)">
                    <span class="phase-num">1</span>
                    <span class="phase-name">페르소나 생성</span>
                </button>
                <button class="phase-tab" data-phase="2" onclick="switchPhase(2)" disabled>
                    <span class="phase-num">2</span>
                    <span class="phase-name">크리에이팅</span>
                </button>
                <button class="phase-tab" data-phase="3" onclick="switchPhase(3)" disabled>
                    <span class="phase-num">3</span>
                    <span class="phase-name">검증</span>
                </button>
            </div>

            <div class="sidebar-content">
                <!-- Phase 1: 페르소나 생성을 위한 입력 -->
                <div class="phase-content active" id="phaseContent1">
                    <div class="phase-description">
                        <p>Reference 게임의 리뷰를 분석하여 <strong>3개의 유저 페르소나</strong>를 생성합니다.</p>
                    </div>

                    <div class="input-section">
                        <div class="input-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>장르 / 태그 <span class="genre-count" id="genreCount"></span></span>
                            <button class="tag-reset-btn" onclick="clearAllFilters()" style="margin-left: auto;">초기화</button>
                        </div>
                    <div class="input-card">
                        <!-- 장르 -->
                        <div class="filter-subsection">
                            <div class="filter-sublabel">장르</div>
                            <div class="genre-grid" id="genreGrid">
                                <button class="genre-btn" data-genre="shooter">Shooter</button>
                                <button class="genre-btn" data-genre="battle_royale">Battle Royale</button>
                                <button class="genre-btn" data-genre="roguelite">Roguelite</button>
                                <button class="genre-btn" data-genre="rpg">RPG</button>
                                <button class="genre-btn" data-genre="action">Action</button>
                                <button class="genre-btn" data-genre="strategy">Strategy</button>
                                <button class="genre-btn" data-genre="simulation">Simulation</button>
                                <button class="genre-btn" data-genre="survival">Survival</button>
                                <button class="filter-expand-btn" id="genreExpandBtn" onclick="toggleGenreExpand()"><span id="genreExpandText">(+12)</span></button>
                            </div>
                            <div class="genre-grid genre-expanded" id="genreGridExpanded" style="display: none;">
                                <button class="genre-btn" data-genre="horror">Horror</button>
                                <button class="genre-btn" data-genre="puzzle">Puzzle</button>
                                <button class="genre-btn" data-genre="platformer">Platformer</button>
                                <button class="genre-btn" data-genre="racing">Racing</button>
                                <button class="genre-btn" data-genre="sports">Sports</button>
                                <button class="genre-btn" data-genre="fighting">Fighting</button>
                                <button class="genre-btn" data-genre="mmo">MMO</button>
                                <button class="genre-btn" data-genre="sandbox">Sandbox</button>
                                <button class="genre-btn" data-genre="card_game">Card Game</button>
                                <button class="genre-btn" data-genre="tower_defense">Tower Defense</button>
                                <button class="genre-btn" data-genre="visual_novel">Visual Novel</button>
                                <button class="genre-btn" data-genre="idle">Idle</button>
                            </div>
                        </div>
                        
                        <!-- 태그 -->
                        <div class="filter-subsection">
                            <div class="filter-sublabel">태그</div>
                            <div class="tag-filter-list" id="tagFilterList">
                                <button class="tag-filter-btn" data-tag="Multiplayer">Multiplayer</button>
                                <button class="tag-filter-btn" data-tag="Singleplayer">Singleplayer</button>
                                <button class="tag-filter-btn" data-tag="Co-op">Co-op</button>
                                <button class="tag-filter-btn" data-tag="PvP">PvP</button>
                                <button class="tag-filter-btn" data-tag="Online">Online</button>
                                <button class="tag-filter-btn" data-tag="Indie">Indie</button>
                                <button class="tag-filter-btn" data-tag="Free to Play">F2P</button>
                                <button class="tag-filter-btn" data-tag="Difficult">Difficult</button>
                                <button class="tag-filter-btn" data-tag="Casual">Casual</button>
                                <button class="filter-expand-btn" id="tagExpandBtn" onclick="toggleTagFilterExpand()"><span id="tagFilterExpandText">(+12)</span></button>
                            </div>
                            <div class="tag-filter-list tag-filter-expanded" id="tagFilterExpanded" style="display: none;">
                                <button class="tag-filter-btn" data-tag="2D">2D</button>
                                <button class="tag-filter-btn" data-tag="3D">3D</button>
                                <button class="tag-filter-btn" data-tag="Pixel Graphics">Pixel</button>
                                <button class="tag-filter-btn" data-tag="Realistic">Realistic</button>
                                <button class="tag-filter-btn" data-tag="Story Rich">Story Rich</button>
                                <button class="tag-filter-btn" data-tag="Atmospheric">Atmospheric</button>
                                <button class="tag-filter-btn" data-tag="Open World">Open World</button>
                                <button class="tag-filter-btn" data-tag="Procedural">Procedural</button>
                                <button class="tag-filter-btn" data-tag="Crafting">Crafting</button>
                                <button class="tag-filter-btn" data-tag="Building">Building</button>
                                <button class="tag-filter-btn" data-tag="Controller">Controller</button>
                                <button class="tag-filter-btn" data-tag="Early Access">Early Access</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="input-section">
                    <div class="input-label">Reference 게임 <span id="selectedRefCount" class="ref-count-badge">0</span></div>
                    <div class="input-card" id="refCard">
                        <!-- 선택된 게임 목록 -->
                        <div class="selected-games-list" id="selectedGamesList" style="display: none;">
                            <div class="selected-games-header">
                                <span>선택된 게임</span>
                                <button class="selected-games-clear" onclick="clearSelectedGames()">전체 제거</button>
                            </div>
                            <div class="selected-games-items" id="selectedGamesItems"></div>
                        </div>
                        
                        <!-- 검색 입력 -->
                        <div class="ref-search-wrapper">
                            <input type="text" class="ref-search-input" id="refSearchInput" placeholder="게임 제목으로 검색..." oninput="debounceSearch(this.value)">
                            <div class="ref-search-results" id="refSearchResults"></div>
                        </div>
                        
                        <div class="ref-divider">
                            <span>또는 추천에서 선택</span>
                        </div>
                        
                        <div class="ref-header">
                            <span style="font-size: 11px; color: var(--text-muted);">정렬</span>
                            <div class="ref-sort-tabs">
                                <button class="ref-sort-btn active" data-sort="popular">인기</button>
                                <button class="ref-sort-btn" data-sort="rating">평가</button>
                                <button class="ref-sort-btn" data-sort="recent">최신</button>
                            </div>
                        </div>
                        <div class="ref-list" id="refList">
                            <div class="ref-loading" id="refLoading" style="display: none;">
                                <div class="spinner"></div>
                                <div>추천 게임 로딩중...</div>
                            </div>
                            <div id="refEmpty" style="text-align: center; padding: 20px; color: var(--text-muted); font-size: 12px;">
                                장르를 선택하면 추천이 표시됩니다
                            </div>
                        </div>
                    </div>
                </div>
                </div><!-- /Phase 1 Content -->

                <!-- Phase 2: 아이디어 크리에이팅 입력 -->
                <div class="phase-content" id="phaseContent2">
                    <div class="phase-description">
                        <p>생성된 페르소나를 기반으로 <strong>멀티 에이전트 팀</strong>이 아이디어를 발전시킵니다.</p>
                    </div>

                    <div class="input-section">
                        <div class="input-label">아이디어 / 컨텍스트</div>
                        <div class="input-card">
                            <textarea class="input-textarea" id="ideaInput" rows="5" placeholder="예: 신규 TPS 게임에 로그라이크 스킬 빌드 시스템을 추가하려고 합니다. 각 라운드마다 스킬을 선택하고 빌드를 완성하는 방식입니다."></textarea>
                        </div>
                    </div>

                    <div class="input-section">
                        <div class="input-label">생성된 페르소나</div>
                        <div class="persona-chips" id="generatedPersonaChips">
                            <div class="empty-personas">Phase 1을 먼저 완료해주세요</div>
                        </div>
                    </div>

                    <div class="input-section">
                        <div class="input-label">에이전트 팀 구성</div>
                        <div class="agent-team-preview">
                            <div class="agent-chip">🎮 게임 디렉터</div>
                            <div class="agent-chip">📝 컨텐츠 디자이너</div>
                            <div class="agent-chip">⚖️ 밸런스 디자이너</div>
                            <div class="agent-chip">⚙️ 시스템 디자이너</div>
                            <div class="agent-chip">📊 PM</div>
                            <div class="agent-chip">🎨 아트 디렉터</div>
                        </div>
                    </div>

                    <div class="input-section">
                        <div class="input-label">추가 컨텍스트 <span class="badge-coming">Coming Soon</span></div>
                        <div class="input-card disabled">
                            <div class="context-source">
                                <span class="context-icon">📚</span>
                                <span>Confluence Space 연동</span>
                                <span class="badge-muted">OAuth 필요</span>
                            </div>
                        </div>
                    </div>
                </div><!-- /Phase 2 Content -->

                <!-- Phase 3: 검증 설정 -->
                <div class="phase-content" id="phaseContent3">
                    <div class="phase-description">
                        <p>크리에이팅 결과물을 <strong>QA 관점</strong>에서 검증합니다.</p>
                    </div>

                    <div class="input-section">
                        <div class="input-label">검증 대상</div>
                        <div class="validation-target" id="validationTarget">
                            <div class="empty-target">Phase 2를 먼저 완료해주세요</div>
                        </div>
                    </div>

                    <div class="input-section">
                        <div class="input-label">검증 기준</div>
                        <div class="validation-criteria">
                            <label class="criteria-item">
                                <input type="checkbox" checked> 밸런스 / 공정성
                            </label>
                            <label class="criteria-item">
                                <input type="checkbox" checked> 유저 경험 (UX)
                            </label>
                            <label class="criteria-item">
                                <input type="checkbox" checked> 기술적 실현가능성
                            </label>
                            <label class="criteria-item">
                                <input type="checkbox" checked> 운영 / 유지보수
                            </label>
                            <label class="criteria-item">
                                <input type="checkbox" checked> 수익화 영향
                            </label>
                        </div>
                    </div>
                </div><!-- /Phase 3 Content -->
            </div>
        </aside>

        <!-- 메인 영역 -->
        <div class="main-area">
            <!-- Phase 인디케이터 -->
            <div class="phase-indicator">
                <div class="phase-indicator-item active" data-phase="1">
                    <div class="phase-indicator-badge">Phase 1</div>
                    <div class="phase-indicator-title">페르소나 생성</div>
                </div>
                <div class="phase-indicator-arrow">→</div>
                <div class="phase-indicator-item" data-phase="2">
                    <div class="phase-indicator-badge">Phase 2</div>
                    <div class="phase-indicator-title">크리에이팅</div>
                </div>
                <div class="phase-indicator-arrow">→</div>
                <div class="phase-indicator-item" data-phase="3">
                    <div class="phase-indicator-badge">Phase 3</div>
                    <div class="phase-indicator-title">검증</div>
                </div>
            </div>

            <!-- 파이프라인 (2줄 통합) -->
            <div class="pipeline-header">
                <!-- 줄 1: Phase 1 + Phase 3 -->
                <div class="pipeline-row">
                    <div class="pipeline-steps pipeline-phase1">
                        <div class="pipeline-step pending" data-step="1">
                            <div class="step-icon">1</div>
                            <div class="step-info">
                                <div class="step-label">리뷰 수집</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="2">
                            <div class="step-icon">2</div>
                            <div class="step-info">
                                <div class="step-label">태깅</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="3">
                            <div class="step-icon">3</div>
                            <div class="step-info">
                                <div class="step-label">페르소나</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                    </div>
                    <div class="pipeline-divider">→</div>
                    <div class="pipeline-steps pipeline-phase3">
                        <div class="pipeline-step pending phase3-step" data-step="9">
                            <div class="step-icon">🔍</div>
                            <div class="step-info">
                                <div class="step-label">QA 검증</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 줄 2: Phase 2 -->
                <div class="pipeline-row">
                    <div class="pipeline-steps pipeline-phase2">
                        <div class="pipeline-step pending" data-step="4">
                            <div class="step-icon">🎮</div>
                            <div class="step-info">
                                <div class="step-label">게임 디렉터</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="5">
                            <div class="step-icon">📝</div>
                            <div class="step-info">
                                <div class="step-label">컨텐츠</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="6">
                            <div class="step-icon">⚖️</div>
                            <div class="step-info">
                                <div class="step-label">밸런스</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="7">
                            <div class="step-icon">⚙️</div>
                            <div class="step-info">
                                <div class="step-label">시스템</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                        <div class="pipeline-step pending" data-step="8">
                            <div class="step-icon">📊</div>
                            <div class="step-info">
                                <div class="step-label">종합</div>
                                <div class="step-desc">대기중</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 메인 콘텐츠 -->
            <div class="main-content">
                <div class="content-area" id="contentArea">
                    <!-- 초기 상태 -->
                    <div class="step-view active" id="stepView0">
                        <div class="empty-state">
                            <div class="empty-icon">?</div>
                            <div class="empty-title">아이디어를 입력하고 시작하세요</div>
                            <div class="empty-desc">
                                좌측에서 아이디어, 장르, Reference 게임을 선택한 후
                                하단의 "분석 시작" 버튼을 클릭하세요
                            </div>
                        </div>
                    </div>

                    <!-- Step 1: 리뷰 수집 -->
                    <div class="step-view" id="stepView1">
                        <div class="step-view-header">
                            <div class="step-view-title">
                                <div class="step-view-icon">1</div>
                                <div>
                                    <h2>리뷰 수집</h2>
                                    <p>Steam API를 통해 Reference 게임의 리뷰를 수집합니다</p>
                                </div>
                            </div>
                        </div>
                        <div class="step-view-content" id="step1Content">
                            <div class="step-main-content">
                                <div class="step-pending">
                                    <div class="step-pending-icon">1</div>
                                    <div class="step-pending-text">분석을 시작하면 리뷰 수집이 진행됩니다</div>
                                </div>
                            </div>
                            <div class="step-log-panel collapsed" id="step1LogPanel">
                                <div class="step-log-header" onclick="toggleStepLog(1)">
                                    <div class="step-log-title">
                                        <span class="step-log-toggle">▶</span>
                                        <span>🔍 분석 과정 보기</span>
                                        <span class="log-badge" id="step1LogBadge">0</span>
                                    </div>
                                </div>
                                <div class="step-log-content" id="step1LogContent">
                                    <div class="step-log-empty">로그가 없습니다</div>
                                    <div class="log-entries" id="step1LogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: 태깅 -->
                    <div class="step-view" id="stepView2">
                        <div class="step-view-header">
                            <div class="step-view-title">
                                <div class="step-view-icon">2</div>
                                <div>
                                    <h2>리뷰 태깅</h2>
                                    <p>수집된 리뷰를 Pain/Delight 태그로 분류합니다</p>
                                </div>
                            </div>
                        </div>
                        <div class="step-view-content" id="step2Content">
                            <div class="step-main-content">
                                <div class="step-pending">
                                    <div class="step-pending-icon">2</div>
                                    <div class="step-pending-text">리뷰 수집 완료 후 태깅이 진행됩니다</div>
                                </div>
                            </div>
                            <div class="step-log-panel collapsed" id="step2LogPanel">
                                <div class="step-log-header" onclick="toggleStepLog(2)">
                                    <div class="step-log-title">
                                        <span class="step-log-toggle">▶</span>
                                        <span>🔍 분석 과정 보기</span>
                                        <span class="log-badge" id="step2LogBadge">0</span>
                                    </div>
                                </div>
                                <div class="step-log-content" id="step2LogContent">
                                    <div class="step-log-empty">로그가 없습니다</div>
                                    <div class="log-entries" id="step2LogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 3: 페르소나 -->
                    <div class="step-view" id="stepView3">
                        <div class="step-view-header">
                            <div class="step-view-title">
                                <div class="step-view-icon">3</div>
                                <div>
                                    <h2>페르소나 도출</h2>
                                    <p>태깅된 리뷰를 기반으로 유저 페르소나를 생성합니다</p>
                                </div>
                            </div>
                        </div>
                        <div class="step-view-content" id="step3Content">
                            <div class="step-main-content">
                                <div class="step-pending">
                                    <div class="step-pending-icon">3</div>
                                    <div class="step-pending-text">태깅 완료 후 페르소나 도출이 진행됩니다</div>
                                </div>
                            </div>
                            <div class="step-log-panel collapsed" id="step3LogPanel">
                                <div class="step-log-header" onclick="toggleStepLog(3)">
                                    <div class="step-log-title">
                                        <span class="step-log-toggle">▶</span>
                                        <span>🔍 분석 과정 보기</span>
                                        <span class="log-badge" id="step3LogBadge">0</span>
                                    </div>
                                </div>
                                <div class="step-log-content" id="step3LogContent">
                                    <div class="step-log-empty">로그가 없습니다</div>
                                    <div class="log-entries" id="step3LogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 4: 검증 -->
                    <div class="step-view" id="stepView4">
                        <div class="step-view-header">
                            <div class="step-view-title">
                                <div class="step-view-icon">4</div>
                                <div>
                                    <h2>아이디어 검증</h2>
                                    <p>페르소나 기반으로 아이디어의 리스크를 분석합니다</p>
                                </div>
                            </div>
                        </div>
                        <div class="step-view-content" id="step4Content">
                            <div class="step-main-content">
                                <div class="step-pending">
                                    <div class="step-pending-icon">4</div>
                                    <div class="step-pending-text">페르소나 도출 후 검증이 진행됩니다</div>
                                </div>
                            </div>
                            <div class="step-log-panel collapsed" id="step4LogPanel">
                                <div class="step-log-header" onclick="toggleStepLog(4)">
                                    <div class="step-log-title">
                                        <span class="step-log-toggle">▶</span>
                                        <span>🔍 분석 과정 보기</span>
                                        <span class="log-badge" id="step4LogBadge">0</span>
                                    </div>
                                </div>
                                <div class="step-log-content" id="step4LogContent">
                                    <div class="step-log-empty">로그가 없습니다</div>
                                    <div class="log-entries" id="step4LogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 5: 리포트 -->
                    <div class="step-view" id="stepView5">
                        <div class="step-view-header">
                            <div class="step-view-title">
                                <div class="step-view-icon">5</div>
                                <div>
                                    <h2>최종 리포트</h2>
                                    <p>검증 결과를 종합한 최종 리포트입니다</p>
                                </div>
                            </div>
                        </div>
                        <div class="step-view-content" id="step5Content">
                            <div class="step-main-content">
                                <div class="step-pending">
                                    <div class="step-pending-icon">5</div>
                                    <div class="step-pending-text">검증 완료 후 리포트가 생성됩니다</div>
                                </div>
                            </div>
                            <div class="step-log-panel collapsed" id="step5LogPanel">
                                <div class="step-log-header" onclick="toggleStepLog(5)">
                                    <div class="step-log-title">
                                        <span class="step-log-toggle">▶</span>
                                        <span>🔍 분석 과정 보기</span>
                                        <span class="log-badge" id="step5LogBadge">0</span>
                                    </div>
                                </div>
                                <div class="step-log-content" id="step5LogContent">
                                    <div class="step-log-empty">로그가 없습니다</div>
                                    <div class="log-entries" id="step5LogEntries"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 우측 패널 -->
                <div class="intervention-panel" id="interventionPanel">
                    <div class="panel-toggle" onclick="togglePanel()" id="panelToggle">
                        <span id="panelToggleIcon">›</span>
                    </div>
                    <div class="panel-header">
                        <h3>Context / 개입</h3>
                    </div>
                    <div class="panel-content">
                        <div class="progress-card">
                            <div class="progress-title">
                                <span class="status-dot connected" id="progressDot"></span>
                                진행 상태
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                            </div>
                            <div class="progress-stats">
                                <div class="progress-stat">
                                    <div class="progress-stat-value" id="stepCount">0/5</div>
                                    <div class="progress-stat-label">단계</div>
                                </div>
                                <div class="progress-stat">
                                    <div class="progress-stat-value" id="tokenCount">0</div>
                                    <div class="progress-stat-label">Tokens</div>
                                </div>
                            </div>
                        </div>

                        <div class="intervention-card">
                            <div class="intervention-header">
                                피드백 / 추가 정보
                            </div>
                            <div class="intervention-body">
                                <textarea class="context-input" id="contextInput" placeholder="예: '하드코어 유저보다 캐주얼 유저를 더 중요하게 봐줘' 또는 '모바일 환경도 고려해야 해'"></textarea>
                                <div class="intervention-actions">
                                    <button class="btn btn-primary" id="applyContextBtn" onclick="applyContext()">컨텍스트 반영</button>
                                </div>
                            </div>
                        </div>

                        <div class="intervention-card">
                            <div class="intervention-header">
                                빠른 개입
                            </div>
                            <div class="intervention-body">
                                <div class="quick-actions">
                                    <button class="quick-btn" onclick="quickIntervene('캐주얼 유저 중심으로 분석해줘')">캐주얼 유저 중심으로</button>
                                    <button class="quick-btn" onclick="quickIntervene('모바일 환경도 고려해줘')">모바일 환경 고려</button>
                                    <button class="quick-btn" onclick="quickIntervene('F2P 모델 기준으로 분석해줘')">F2P 모델 기준</button>
                                    <button class="quick-btn" onclick="quickIntervene('e스포츠 가능성도 체크해줘')">e스포츠 가능성</button>
                                </div>
                            </div>
                        </div>

                        <div class="intervention-card">
                            <div class="intervention-header">
                                개입 히스토리
                            </div>
                            <div class="intervention-body" id="historyList">
                                <div style="text-align: center; color: var(--text-muted); font-size: 11px; padding: 10px;">
                                    아직 개입 기록이 없습니다
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 하단 바 -->
            <div class="bottom-bar">
                <div class="footer-info" id="footerInfo">
                    준비됨
                </div>
                <div class="footer-stats">
                    <span class="footer-stat" id="footerTokens" title="사용된 토큰">0 tokens</span>
                    <span class="footer-stat footer-cost" id="footerCost" title="예상 비용">$0.0000</span>
                </div>
                <div class="footer-actions">
                    <button class="btn btn-ghost btn-lg" onclick="resetAll()">초기화</button>
                    <button class="btn btn-primary btn-lg" id="startBtn" onclick="startCurrentPhase()">Phase 1 시작</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 로그 패널 (숨김 - 각 단계 내 로그 패널 사용) -->
    <div class="log-panel" id="logPanel" style="display: none;">
        <div class="log-header" onclick="toggleLogPanel()">
            <div class="log-header-left">
                <span class="log-toggle-icon" id="logToggleIcon">▲</span>
                <span class="log-title">실행 로그</span>
                <span class="log-badge" id="logBadge">0</span>
            </div>
            <div class="log-header-right">
                <button class="log-clear-btn" onclick="event.stopPropagation(); clearLogs()">Clear</button>
            </div>
        </div>
        <div class="log-content" id="logContent">
            <div class="log-empty" id="logEmpty">분석을 시작하면 로그가 표시됩니다</div>
            <div class="log-entries" id="logEntries"></div>
        </div>
    </div>

    <!-- 상태바 -->
    <div class="status-bar">
        <div class="status-left">
            <div class="status-item" onclick="openSettingsModal()">
                <span class="status-dot" id="apiStatusDot"></span>
                <span id="apiStatusText">API 미설정</span>
            </div>
            <div class="status-item">
                <span>Preset: <span id="presetStatus">Standard</span></span>
            </div>
        </div>
        <div class="status-right">
            <div class="status-item">Vibe Validator v0.1</div>
        </div>
    </div>

    <!-- 토스트 컨테이너 -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- 설정 모달 -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h3>API 설정</h3>
                <button class="modal-close" onclick="closeSettingsModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="setting-group">
                    <div class="setting-label">OpenAI API Key</div>
                    <input type="password" class="setting-input" id="openaiKey" placeholder="sk-...">
                    <div class="api-status" id="openaiStatus"></div>
                    <div class="setting-hint">GPT-4o, GPT-4o-mini 사용</div>
                </div>
                <div class="setting-group">
                    <div class="setting-label">Anthropic API Key</div>
                    <input type="password" class="setting-input" id="anthropicKey" placeholder="sk-ant-...">
                    <div class="api-status" id="anthropicStatus"></div>
                    <div class="setting-hint">Claude 3.5 Sonnet, Claude 3 Haiku 사용</div>
                </div>
                <div class="setting-group">
                    <div class="setting-label">Google AI API Key (Gemini)</div>
                    <input type="password" class="setting-input" id="geminiKey" placeholder="AIza...">
                    <div class="api-status" id="geminiStatus"></div>
                    <div class="setting-hint">Gemini 1.5 Flash (무료 티어 가능)</div>
                </div>
                <div class="setting-group">
                    <div class="setting-label">Google Vertex AI API Key</div>
                    <input type="password" class="setting-input" id="vertexKey" placeholder="aq...">
                    <div class="api-status" id="vertexStatus"></div>
                    <div class="setting-hint">Vertex AI (Claude, Gemini 등 사용 가능)</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeSettingsModal()">취소</button>
                <button class="btn btn-primary" onclick="saveSettings()">저장</button>
            </div>
        </div>
    </div>

    <!-- 프리셋 모달 -->
    <div class="modal-overlay" id="presetModal">
        <div class="modal">
            <div class="modal-header">
                <h3>프리셋 선택</h3>
                <button class="modal-close" onclick="closePresetModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="preset-option" data-preset="free" onclick="selectPreset('free', this)">
                    <div class="preset-option-header">
                        <span class="preset-dot free"></span>
                        <span class="preset-option-name">Free</span>
                    </div>
                    <div class="preset-option-desc">30개/게임 · 1~2 requests · 토큰 절약</div>
                </div>
                <div class="preset-option active" data-preset="standard" onclick="selectPreset('standard', this)">
                    <div class="preset-option-header">
                        <span class="preset-dot standard"></span>
                        <span class="preset-option-name">Standard (추천)</span>
                    </div>
                    <div class="preset-option-desc">100개/게임 · 4~5 requests · 일반 사용</div>
                </div>
                <div class="preset-option" data-preset="detailed" onclick="selectPreset('detailed', this)">
                    <div class="preset-option-header">
                        <span class="preset-dot detailed"></span>
                        <span class="preset-option-name">Detailed</span>
                    </div>
                    <div class="preset-option-desc">300개/게임 · 8~12 requests · 꼼꼼한 분석</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closePresetModal()">취소</button>
                <button class="btn btn-primary" onclick="applyPreset()">적용</button>
            </div>
        </div>
    </div>

    <!-- 되돌림 확인 모달 -->
    <div class="modal-overlay" id="rollbackModal">
        <div class="modal">
            <div class="modal-header">
                <h3>컨텍스트 반영 방식 선택</h3>
                <button class="modal-close" onclick="closeRollbackModal()">×</button>
            </div>
            <div class="modal-body">
                <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 16px;">
                    입력한 컨텍스트를 반영하려면 <strong id="rollbackStep">페르소나</strong> 단계부터 다시 분석해야 합니다.
                </p>
                <div class="rollback-options">
                    <div class="rollback-option" onclick="confirmRollback('current')">
                        <h4>🔄 현재 단계만 재분석</h4>
                        <p>현재 Phase의 마지막 단계만 컨텍스트를 반영하여 재실행합니다. (빠름)</p>
                    </div>
                    <div class="rollback-option" onclick="confirmRollback('rerun')">
                        <h4>🔁 처음부터 재실행</h4>
                        <p>컨텍스트를 반영하여 영향받는 단계부터 모두 다시 분석합니다. (정확함)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== 상태 관리 =====
        const state = {
            // Phase 관리
            currentPhase: 1,
            phaseCompleted: { 1: false, 2: false, 3: false },
            
            // Phase 1: 페르소나 생성
            genres: [],
            tags: [],
            selectedRefs: [],
            personas: [], // 생성된 페르소나 3개
            
            // Phase 2: 크리에이팅
            idea: '',
            creatingResult: null,
            
            // Phase 3: 검증
            validationResult: null,
            
            // 공통
            preset: 'standard',
            currentStep: 0,
            activeView: 0,
            totalTokens: 0,
            tokenDetails: [],
            results: {},
            history: [],
            apis: {
                openai: null,
                anthropic: null,
                gemini: null,
                vertex: null
            }
        };

        // 프리셋 설정
        const presetConfig = {
            free: { reviewsPerGame: 30, name: 'Free' },
            standard: { reviewsPerGame: 100, name: 'Standard' },
            detailed: { reviewsPerGame: 300, name: 'Detailed' }
        };

        // 장르별 Steam 태그 매핑
        const genreTagMap = {
            shooter: ['FPS', 'Third-Person Shooter', 'Shooter'],
            battle_royale: ['Battle Royale', 'Last Man Standing'],
            roguelite: ['Roguelite', 'Roguelike', 'Roguelike Deckbuilder'],
            rpg: ['RPG', 'JRPG', 'Action RPG', 'CRPG'],
            action: ['Action', 'Hack and Slash', 'Beat em up'],
            strategy: ['Strategy', 'RTS', 'Turn-Based Strategy', 'Grand Strategy'],
            simulation: ['Simulation', 'Life Sim', 'Management', 'Building'],
            survival: ['Survival', 'Open World Survival Craft'],
            horror: ['Horror', 'Survival Horror', 'Psychological Horror'],
            puzzle: ['Puzzle', 'Logic', 'Hidden Object'],
            platformer: ['Platformer', '2D Platformer', '3D Platformer'],
            racing: ['Racing', 'Driving', 'Automobile Sim'],
            sports: ['Sports', 'Football', 'Basketball', 'Golf'],
            fighting: ['Fighting', 'Beat em up', 'Martial Arts'],
            mmo: ['MMO', 'MMORPG', 'Massively Multiplayer'],
            sandbox: ['Sandbox', 'Open World', 'Building'],
            card_game: ['Card Game', 'Deckbuilding', 'Trading Card Game'],
            tower_defense: ['Tower Defense', 'Real-Time Tactics'],
            visual_novel: ['Visual Novel', 'Interactive Fiction', 'Choose Your Own Adventure'],
            rhythm: ['Rhythm', 'Music', 'Soundtrack'],
            idle: ['Idler', 'Clicker', 'Incremental'],
            party: ['Party Game', 'Local Multiplayer', 'Couch Co-Op']
        };

        // ===== 로그 시스템 =====
        const logs = [];
        let logCount = 0;

        function log(type, message, detail = null) {
            const now = new Date();
            const time = now.toTimeString().slice(0, 8);
            
            logs.push({ time, type, message, detail });
            logCount++;
            
            renderLogs();
            updateLogBadge();
            
            // 현재 단계의 로그 패널에도 추가
            if (state.currentStep > 0) {
                addStepLog(state.currentStep, type, message, detail);
            }
            
            // 콘솔에도 출력
            const prefix = `[${type.toUpperCase()}]`;
            if (detail) {
                console.log(prefix, message, detail);
            } else {
                console.log(prefix, message);
            }
        }

        function renderLogs() {
            const entriesEl = document.getElementById('logEntries');
            const emptyEl = document.getElementById('logEmpty');
            
            if (logs.length === 0) {
                emptyEl.style.display = 'block';
                entriesEl.innerHTML = '';
                return;
            }
            
            emptyEl.style.display = 'none';
            
            // 최근 100개만 표시
            const recentLogs = logs.slice(-100);
            
            entriesEl.innerHTML = recentLogs.map(l => `
                <div class="log-entry">
                    <span class="log-time">${l.time}</span>
                    <span class="log-type ${l.type}">${l.type}</span>
                    <div class="log-message">
                        ${l.message}
                        ${l.detail ? `<div class="log-detail">${escapeHtml(typeof l.detail === 'object' ? JSON.stringify(l.detail, null, 2) : l.detail)}</div>` : ''}
                    </div>
                </div>
            `).join('');
            
            // 자동 스크롤
            const contentEl = document.getElementById('logContent');
            contentEl.scrollTop = contentEl.scrollHeight;
        }

        function updateLogBadge() {
            const badge = document.getElementById('logBadge');
            badge.textContent = logCount;
            badge.classList.toggle('has-logs', logCount > 0);
        }

        function clearLogs() {
            logs.length = 0;
            logCount = 0;
            renderLogs();
            updateLogBadge();
        }

        function toggleLogPanel() {
            const panel = document.getElementById('logPanel');
            panel.classList.toggle('collapsed');
            panel.classList.toggle('expanded');
        }

        // ===== 초기화 =====
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            setupEventListeners();
            updateAPIStatus();
            
            // 로그 패널 초기 상태
            document.getElementById('logPanel').classList.add('collapsed');
            
            // Phase UI 초기화
            switchPhase(1);
            updateStartButton();
            
            log('info', '시스템 초기화 완료');
        });

        function setupEventListeners() {
            // 아이디어 입력 (Phase 2)
            const ideaInput = document.getElementById('ideaInput');
            if (ideaInput) {
                ideaInput.addEventListener('input', (e) => {
                    state.idea = e.target.value;
                });
            }

            // 장르 선택 (다중)
            document.querySelectorAll('.genre-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const genre = btn.dataset.genre;
                    
                    if (btn.classList.contains('selected')) {
                        // 선택 해제
                        btn.classList.remove('selected');
                        state.genres = state.genres.filter(g => g !== genre);
                    } else {
                        // 선택 추가
                        btn.classList.add('selected');
                        state.genres.push(genre);
                    }
                    
                    updateGenreCount();
                    
                    if (state.genres.length > 0) {
                        loadReferenceGames();
                    } else {
                        clearReferenceList();
                    }
                });
            });

            // 정렬 탭
            document.querySelectorAll('.ref-sort-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.ref-sort-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    if (state.genres.length > 0 || state.tags.length > 0) {
                        loadReferenceGames(btn.dataset.sort);
                    }
                });
            });

            // 태그 필터
            document.querySelectorAll('.tag-filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // X 버튼 클릭 시에만 제거
                    if (e.target.classList.contains('tag-remove')) {
                        e.stopPropagation();
                        const tag = btn.dataset.tag;
                        btn.classList.remove('selected');
                        btn.querySelector('.tag-remove')?.remove();
                        state.tags = state.tags.filter(t => t !== tag);
                        updateGenreCount();
                        if (state.genres.length > 0 || state.tags.length > 0) {
                            loadReferenceGames();
                        } else {
                            clearReferenceList();
                        }
                        return;
                    }
                    
                    const tag = btn.dataset.tag;
                    
                    if (btn.classList.contains('selected')) {
                        btn.classList.remove('selected');
                        btn.querySelector('.tag-remove')?.remove();
                        state.tags = state.tags.filter(t => t !== tag);
                    } else {
                        btn.classList.add('selected');
                        // X 버튼 추가
                        const removeBtn = document.createElement('span');
                        removeBtn.className = 'tag-remove';
                        removeBtn.textContent = '×';
                        removeBtn.onclick = (e) => {
                            e.stopPropagation();
                            btn.classList.remove('selected');
                            removeBtn.remove();
                            state.tags = state.tags.filter(t => t !== tag);
                            updateGenreCount();
                            if (state.genres.length > 0 || state.tags.length > 0) {
                                loadReferenceGames();
                            } else {
                                clearReferenceList();
                            }
                        };
                        btn.appendChild(removeBtn);
                        state.tags.push(tag);
                    }
                    
                    updateGenreCount();
                    
                    if (state.genres.length > 0 || state.tags.length > 0) {
                        loadReferenceGames();
                    } else {
                        clearReferenceList();
                    }
                });
            });

            // 파이프라인 단계 클릭
            document.querySelectorAll('.pipeline-step').forEach(step => {
                step.addEventListener('click', () => {
                    const stepNum = parseInt(step.dataset.step);
                    // 완료된 단계 또는 현재 단계까지만 이동 가능
                    if (stepNum <= state.currentStep || state.currentStep === 0) {
                        switchToView(stepNum);
                    }
                });
            });
        }

        function switchToView(viewNum) {
            state.activeView = viewNum;
            
            // 모든 뷰 숨기기
            document.querySelectorAll('.step-view').forEach(view => {
                view.classList.remove('active');
            });
            
            // 해당 뷰 표시
            const targetView = document.getElementById(`stepView${viewNum}`);
            if (targetView) {
                targetView.classList.add('active');
            }

            // 파이프라인 단계 시각적 표시 업데이트
            updatePipelineVisual(viewNum);
        }

        function updatePipelineVisual(activeViewNum) {
            document.querySelectorAll('.pipeline-step').forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.remove('viewing');
                if (stepNum === activeViewNum && stepNum <= state.currentStep) {
                    step.classList.add('viewing');
                }
            });
        }

        function updateIdeaCard() {
            // Legacy function - no longer needed with Phase-based UI
        }

        function updateGenreCount() {
            const genreText = state.genres.length > 0 ? `${state.genres.length}개 장르` : '';
            const tagText = state.tags.length > 0 ? `${state.tags.length}개 태그` : '';
            const combined = [genreText, tagText].filter(Boolean).join(', ');
            document.getElementById('genreCount').textContent = combined ? `(${combined})` : '';
        }

        function toggleGenreExpand() {
            const grid = document.getElementById('genreGrid');
            const expanded = document.getElementById('genreGridExpanded');
            const text = document.getElementById('genreExpandText');
            
            if (expanded.style.display === 'none') {
                expanded.style.display = 'flex';
                grid.classList.add('expanded');
                text.textContent = '접기';
            } else {
                expanded.style.display = 'none';
                grid.classList.remove('expanded');
                text.textContent = '(+12)';
            }
        }

        function clearReferenceList() {
            const listEl = document.getElementById('refList');
            listEl.querySelectorAll('.ref-item').forEach(el => el.remove());
            document.getElementById('refEmpty').style.display = 'block';
            document.getElementById('refEmpty').textContent = '장르 또는 태그를 선택해주세요';
        }

        function clearTagFilters() {
            state.tags = [];
            document.querySelectorAll('.tag-filter-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            if (state.genres.length > 0) {
                loadReferenceGames();
            } else {
                clearReferenceList();
            }
        }

        function toggleTagFilterExpand() {
            const list = document.getElementById('tagFilterList');
            const expanded = document.getElementById('tagFilterExpanded');
            const text = document.getElementById('tagFilterExpandText');
            
            if (expanded.style.display === 'none') {
                expanded.style.display = 'flex';
                list.classList.add('expanded');
                text.textContent = '접기';
            } else {
                expanded.style.display = 'none';
                list.classList.remove('expanded');
                text.textContent = '(+12)';
            }
        }

        function toggleStepLog(stepNum) {
            const panel = document.getElementById(`step${stepNum}LogPanel`);
            const toggle = panel.querySelector('.step-log-toggle');
            const isCollapsed = panel.classList.contains('collapsed');
            
            if (isCollapsed) {
                // 펼칠 때: 패널 위치 기억 후 스크롤 조정
                const panelRect = panel.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                panel.classList.remove('collapsed');
                toggle.textContent = '▼';
                
                // 패널이 화면 하단에 있으면 스크롤하여 내용이 보이도록
                requestAnimationFrame(() => {
                    const content = panel.querySelector('.step-log-content');
                    if (content) {
                        content.scrollTop = content.scrollHeight; // 최신 로그로 스크롤
                    }
                    // 패널이 뷰포트 하단 근처에 있으면 살짝 스크롤
                    const newRect = panel.getBoundingClientRect();
                    if (newRect.bottom > viewportHeight - 50) {
                        panel.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }
                });
            } else {
                // 접을 때
                panel.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        function clearStepLog(stepNum) {
            const entries = document.getElementById(`step${stepNum}LogEntries`);
            const empty = entries.parentElement.querySelector('.step-log-empty');
            entries.innerHTML = '';
            empty.style.display = 'block';
            updateStepLogBadge(stepNum, 0);
        }

        function updateStepLogBadge(stepNum, count) {
            const badge = document.getElementById(`step${stepNum}LogBadge`);
            if (badge) {
                badge.textContent = count;
                if (count > 0) {
                    badge.classList.add('has-logs');
                } else {
                    badge.classList.remove('has-logs');
                }
            }
        }

        function addStepLog(stepNum, type, message, detail = null) {
            const entries = document.getElementById(`step${stepNum}LogEntries`);
            
            // 해당 step의 로그 패널이 없으면 무시
            if (!entries) {
                return;
            }
            
            const empty = entries.parentElement?.querySelector('.step-log-empty');
            
            if (empty) {
                empty.style.display = 'none';
            }

            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            // 아이콘 매핑
            const icons = {
                'api': '🔗',
                'success': '✓',
                'error': '✗',
                'info': '→',
                'step': '📋',
                'context': '📝'
            };
            
            // HTML 태그 제거 (깔끔하게)
            const cleanMessage = message.replace(/<[^>]*>/g, '');
            
            let logHtml = `
                <span class="log-time">${time}</span>
                <span class="log-icon">${icons[type] || '•'}</span>
                <span class="log-message">${cleanMessage}</span>
            `;
            
            entry.innerHTML = logHtml;
            entries.appendChild(entry);
            
            // 스크롤을 맨 아래로
            const content = entries.parentElement;
            content.scrollTop = content.scrollHeight;
            
            // 배지 업데이트
            const count = entries.children.length;
            updateStepLogBadge(stepNum, count);
        }

        // ===== 게임 검색 =====
        let searchTimeout = null;

        function debounceSearch(query) {
            clearTimeout(searchTimeout);
            
            const resultsEl = document.getElementById('refSearchResults');
            
            if (query.trim().length < 2) {
                resultsEl.classList.remove('active');
                return;
            }

            resultsEl.innerHTML = '<div class="ref-search-loading">검색중...</div>';
            resultsEl.classList.add('active');

            searchTimeout = setTimeout(() => {
                searchGames(query.trim());
            }, 300);
        }

        async function searchGames(query) {
            const resultsEl = document.getElementById('refSearchResults');
            
            try {
                // Steam Store Search API (CORS 프록시 사용)
                const searchUrl = `https://store.steampowered.com/api/storesearch/?term=${encodeURIComponent(query)}&l=korean&cc=KR`;
                
                const response = await fetchWithProxy(searchUrl);
                const data = await response.json();
                
                if (data.items && data.items.length > 0) {
                    renderSearchResults(data.items.slice(0, 8));
                } else {
                    resultsEl.innerHTML = '<div class="ref-search-loading">검색 결과가 없습니다</div>';
                }
            } catch (error) {
                console.error('Search error:', error);
                // 폴백: 더미 검색 결과
                const dummyResults = searchDummyGames(query);
                if (dummyResults.length > 0) {
                    renderSearchResults(dummyResults);
                } else {
                    resultsEl.innerHTML = '<div class="ref-search-loading">검색 결과가 없습니다</div>';
                }
            }
        }

        function searchDummyGames(query) {
            // 모든 더미 게임에서 검색
            const allGames = [];
            Object.values(getDummyGamesAll()).forEach(games => {
                allGames.push(...games);
            });
            
            const q = query.toLowerCase();
            return allGames
                .filter(g => g.name.toLowerCase().includes(q))
                .slice(0, 8)
                .map(g => ({
                    id: g.appid,
                    name: g.name,
                    tiny_image: `https://cdn.cloudflare.steamstatic.com/steam/apps/${g.appid}/capsule_184x69.jpg`,
                    price: null
                }));
        }

        function getDummyGamesAll() {
            return {
                shooter: [
                    { appid: '578080', name: 'PUBG: BATTLEGROUNDS', owners: 75000000, rating: 72 },
                    { appid: '1172470', name: 'Apex Legends', owners: 35000000, rating: 85 },
                    { appid: '359550', name: "Tom Clancy's Rainbow Six Siege", owners: 70000000, rating: 87 },
                    { appid: '730', name: 'Counter-Strike 2', owners: 100000000, rating: 86 },
                    { appid: '1938090', name: 'Call of Duty: Warzone', owners: 40000000, rating: 68 },
                    { appid: '271590', name: 'Grand Theft Auto V', owners: 85000000, rating: 89 },
                    { appid: '594650', name: 'Hunt: Showdown', owners: 5000000, rating: 82 },
                    { appid: '1966720', name: 'Lethal Company', owners: 15000000, rating: 97 }
                ],
                roguelite: [
                    { appid: '1145360', name: 'Hades', owners: 6000000, rating: 97 },
                    { appid: '2379780', name: 'Balatro', owners: 3000000, rating: 98 },
                    { appid: '1794680', name: 'Vampire Survivors', owners: 5000000, rating: 98 },
                    { appid: '311690', name: 'Enter the Gungeon', owners: 4000000, rating: 93 },
                    { appid: '851730', name: 'Noita', owners: 2000000, rating: 93 },
                    { appid: '588650', name: 'Dead Cells', owners: 5000000, rating: 95 },
                    { appid: '646570', name: 'Slay the Spire', owners: 4000000, rating: 97 }
                ],
                rpg: [
                    { appid: '1245620', name: 'ELDEN RING', owners: 20000000, rating: 92 },
                    { appid: '1091500', name: "Baldur's Gate 3", owners: 15000000, rating: 96 },
                    { appid: '292030', name: 'The Witcher 3', owners: 40000000, rating: 95 },
                    { appid: '374320', name: 'DARK SOULS III', owners: 10000000, rating: 89 },
                    { appid: '1174180', name: 'Red Dead Redemption 2', owners: 8000000, rating: 90 },
                    { appid: '582010', name: 'Monster Hunter: World', owners: 7000000, rating: 88 }
                ],
                survival: [
                    { appid: '892970', name: 'Valheim', owners: 12000000, rating: 95 },
                    { appid: '252490', name: 'Rust', owners: 14000000, rating: 85 },
                    { appid: '346110', name: 'ARK: Survival Evolved', owners: 20000000, rating: 78 },
                    { appid: '1623730', name: 'Palworld', owners: 15000000, rating: 83 },
                    { appid: '1149460', name: 'Sons Of The Forest', owners: 5000000, rating: 85 },
                    { appid: '105600', name: 'Terraria', owners: 40000000, rating: 97 },
                    { appid: '264710', name: 'Subnautica', owners: 8000000, rating: 96 }
                ]
            };
        }

        function renderSearchResults(items) {
            const resultsEl = document.getElementById('refSearchResults');
            
            resultsEl.innerHTML = items.map(item => {
                const isAdded = state.selectedRefs.some(r => r.appid === String(item.id));
                return `
                    <div class="ref-search-item ${isAdded ? 'added' : ''}" onclick="addSearchResult('${item.id}', '${escapeHtml(item.name)}')">
                        <div class="ref-search-thumb">
                            <img src="${item.tiny_image}" alt="" onerror="this.style.display='none'">
                        </div>
                        <div class="ref-search-info">
                            <div class="ref-search-name">${escapeHtml(item.name)}</div>
                            <div class="ref-search-meta">AppID: ${item.id}</div>
                        </div>
                        <div class="ref-search-add">${isAdded ? '✓' : '+'}</div>
                    </div>
                `;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function addSearchResult(appid, name) {
            const existing = state.selectedRefs.find(r => r.appid === appid);
            
            if (existing) {
                // 이미 추가된 경우 제거
                state.selectedRefs = state.selectedRefs.filter(r => r.appid !== appid);
                showToast(`${name} 제거됨`, 'success');
            } else {
                // 새로 추가
                state.selectedRefs.push({
                    appid: appid,
                    name: name,
                    owners: 0,
                    rating: 0
                });
                showToast(`${name} 추가됨`, 'success');
            }
            
            updateSelectedRefCount();
            
            // 검색 결과 UI 업데이트
            const query = document.getElementById('refSearchInput').value.trim();
            if (query.length >= 2) {
                searchGames(query);
            }
        }

        // 검색 결과 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            const wrapper = document.querySelector('.ref-search-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('refSearchResults').classList.remove('active');
            }
        });

        // ===== API 설정 =====
        function loadSettings() {
            const saved = localStorage.getItem('vibeValidator_settings');
            if (saved) {
                const settings = JSON.parse(saved);
                state.apis = settings.apis || {};
                state.preset = settings.preset || 'standard';
                
                document.getElementById('openaiKey').value = state.apis.openai || '';
                document.getElementById('anthropicKey').value = state.apis.anthropic || '';
                document.getElementById('geminiKey').value = state.apis.gemini || '';
                document.getElementById('vertexKey').value = state.apis.vertex || '';
                
                updatePresetUI();
            }
        }

        function saveSettings() {
            state.apis.openai = document.getElementById('openaiKey').value.trim() || null;
            state.apis.anthropic = document.getElementById('anthropicKey').value.trim() || null;
            state.apis.gemini = document.getElementById('geminiKey').value.trim() || null;
            state.apis.vertex = document.getElementById('vertexKey').value.trim() || null;

            localStorage.setItem('vibeValidator_settings', JSON.stringify({
                apis: state.apis,
                preset: state.preset
            }));

            updateAPIStatus();
            closeSettingsModal();
            showToast('설정이 저장되었습니다', 'success');
        }

        function updateAPIStatus() {
            const dot = document.getElementById('apiStatusDot');
            const text = document.getElementById('apiStatusText');
            
            const activeAPIs = [];
            if (state.apis.openai) activeAPIs.push('OpenAI');
            if (state.apis.anthropic) activeAPIs.push('Anthropic');
            if (state.apis.gemini) activeAPIs.push('Gemini');
            if (state.apis.vertex) activeAPIs.push('Vertex');

            if (activeAPIs.length > 0) {
                dot.className = 'status-dot connected';
                text.textContent = activeAPIs.join(', ');
            } else {
                dot.className = 'status-dot disconnected';
                text.textContent = 'API 미설정 (클릭하여 설정)';
            }

            // 모달 내 상태 표시
            updateAPIStatusInModal('openai', state.apis.openai);
            updateAPIStatusInModal('anthropic', state.apis.anthropic);
            updateAPIStatusInModal('gemini', state.apis.gemini);
            updateAPIStatusInModal('vertex', state.apis.vertex);
        }

        function updateAPIStatusInModal(provider, key) {
            const statusEl = document.getElementById(`${provider}Status`);
            if (key) {
                statusEl.className = 'api-status valid';
                statusEl.textContent = '✓ 설정됨';
            } else {
                statusEl.className = 'api-status';
                statusEl.textContent = '';
            }
        }

        // ===== Reference 게임 로드 =====
        async function loadReferenceGames(sortBy = 'popular') {
            const listEl = document.getElementById('refList');
            const loadingEl = document.getElementById('refLoading');
            const emptyEl = document.getElementById('refEmpty');

            if (state.genres.length === 0 && state.tags.length === 0) return;

            // 로딩 표시
            loadingEl.style.display = 'block';
            emptyEl.style.display = 'none';
            listEl.querySelectorAll('.ref-item').forEach(el => el.remove());

            try {
                let allGames = [];
                
                if (state.genres.length > 0) {
                    // 선택된 모든 장르에서 게임 수집
                    for (const genre of state.genres) {
                        const dummyGames = getDummyGames(genre, sortBy);
                        allGames = allGames.concat(dummyGames);
                    }
                } else if (state.tags.length > 0) {
                    // 태그만 선택된 경우 모든 게임에서 필터링
                    Object.entries(gamesWithTags).forEach(([appid, game]) => {
                        if (state.tags.every(tag => game.tags?.includes(tag))) {
                            allGames.push({ appid, ...game });
                        }
                    });
                }

                // 중복 제거 및 정렬
                const uniqueGames = dedupeAndSortGames(allGames, sortBy);
                
                loadingEl.style.display = 'none';
                
                if (uniqueGames.length > 0) {
                    renderReferenceGames(uniqueGames.slice(0, 10));
                } else {
                    emptyEl.style.display = 'block';
                    emptyEl.textContent = '조건에 맞는 게임이 없습니다';
                }
            } catch (error) {
                console.error('Failed to load games:', error);
                loadingEl.style.display = 'none';
                emptyEl.style.display = 'block';
                emptyEl.textContent = '게임을 불러오는데 실패했습니다';
            }
        }

        function dedupeAndSortGames(games, sortBy) {
            // appid 기준 중복 제거
            const seen = new Set();
            const unique = games.filter(g => {
                if (seen.has(g.appid)) return false;
                seen.add(g.appid);
                return true;
            });

            // 정렬
            switch (sortBy) {
                case 'popular':
                    unique.sort((a, b) => b.owners - a.owners);
                    break;
                case 'rating':
                    unique.sort((a, b) => b.rating - a.rating);
                    break;
                case 'recent':
                    unique.sort(() => Math.random() - 0.5);
                    break;
            }

            return unique;
        }

        async function fetchSteamGames(tag, sortBy) {
            // SteamSpy API (CORS 프록시 사용)
            const apiUrl = `https://steamspy.com/api.php?request=tag&tag=${encodeURIComponent(tag)}`;
            
            const response = await fetchWithProxy(apiUrl);
            const data = await response.json();
            
            // 데이터 변환 및 정렬
            let games = Object.entries(data).map(([appid, info]) => ({
                appid: appid,
                name: info.name,
                owners: parseInt(info.owners.split('..')[0].replace(/,/g, '')) || 0,
                rating: info.positive / (info.positive + info.negative) * 100 || 0,
                recent: info.userscore || 0
            }));

            // 정렬
            switch (sortBy) {
                case 'popular':
                    games.sort((a, b) => b.owners - a.owners);
                    break;
                case 'rating':
                    games.sort((a, b) => b.rating - a.rating);
                    break;
                case 'recent':
                    games.sort((a, b) => b.recent - a.recent);
                    break;
            }

            return games.slice(0, 10);
        }

        // 태그 정보가 포함된 게임 데이터
        const gamesWithTags = {
            '578080': { name: 'PUBG: BATTLEGROUNDS', owners: 75000000, rating: 72, tags: ['Multiplayer', 'PvP', 'Online', 'Competitive', '3D', 'Realistic'] },
            '1172470': { name: 'Apex Legends', owners: 35000000, rating: 85, tags: ['Multiplayer', 'PvP', 'Free to Play', 'Online', 'Competitive', '3D', 'Fast-Paced'] },
            '359550': { name: "Tom Clancy's Rainbow Six Siege", owners: 70000000, rating: 87, tags: ['Multiplayer', 'PvP', 'Online', 'Competitive', '3D', 'Realistic'] },
            '730': { name: 'Counter-Strike 2', owners: 100000000, rating: 86, tags: ['Multiplayer', 'PvP', 'Free to Play', 'Online', 'Competitive', '3D', 'Fast-Paced'] },
            '1938090': { name: 'Call of Duty: Warzone', owners: 40000000, rating: 68, tags: ['Multiplayer', 'PvP', 'Free to Play', 'Online', '3D', 'Realistic'] },
            '271590': { name: 'Grand Theft Auto V', owners: 85000000, rating: 89, tags: ['Multiplayer', 'Singleplayer', 'Open World', '3D', 'Story Rich', 'Realistic'] },
            '594650': { name: 'Hunt: Showdown', owners: 5000000, rating: 82, tags: ['Multiplayer', 'PvP', 'Online', 'Atmospheric', '3D', 'Difficult'] },
            '1966720': { name: 'Lethal Company', owners: 15000000, rating: 97, tags: ['Multiplayer', 'Co-op', 'Online', 'Indie', '3D', 'Atmospheric'] },
            '1145360': { name: 'Hades', owners: 6000000, rating: 97, tags: ['Singleplayer', 'Indie', 'Story Rich', 'Fast-Paced', '2D', 'Difficult', 'Controller'] },
            '2379780': { name: 'Balatro', owners: 3000000, rating: 98, tags: ['Singleplayer', 'Indie', 'Casual', '2D', 'Relaxing'] },
            '1794680': { name: 'Vampire Survivors', owners: 5000000, rating: 98, tags: ['Singleplayer', 'Indie', 'Casual', '2D', 'Pixel Graphics', 'Relaxing'] },
            '311690': { name: 'Enter the Gungeon', owners: 4000000, rating: 93, tags: ['Singleplayer', 'Co-op', 'Indie', '2D', 'Pixel Graphics', 'Difficult'] },
            '851730': { name: 'Noita', owners: 2000000, rating: 93, tags: ['Singleplayer', 'Indie', '2D', 'Pixel Graphics', 'Difficult', 'Procedural'] },
            '588650': { name: 'Dead Cells', owners: 5000000, rating: 95, tags: ['Singleplayer', 'Indie', '2D', 'Pixel Graphics', 'Difficult', 'Fast-Paced', 'Controller'] },
            '646570': { name: 'Slay the Spire', owners: 4000000, rating: 97, tags: ['Singleplayer', 'Indie', '2D', 'Turn-Based', 'Relaxing'] },
            '1245620': { name: 'ELDEN RING', owners: 20000000, rating: 92, tags: ['Singleplayer', 'Co-op', 'Open World', '3D', 'Difficult', 'Story Rich', 'Atmospheric'] },
            '1091500': { name: "Baldur's Gate 3", owners: 15000000, rating: 96, tags: ['Singleplayer', 'Co-op', '3D', 'Turn-Based', 'Story Rich'] },
            '292030': { name: 'The Witcher 3', owners: 40000000, rating: 95, tags: ['Singleplayer', 'Open World', '3D', 'Story Rich', 'Atmospheric'] },
            '374320': { name: 'DARK SOULS III', owners: 10000000, rating: 89, tags: ['Singleplayer', 'Co-op', '3D', 'Difficult', 'Atmospheric'] },
            '1174180': { name: 'Red Dead Redemption 2', owners: 8000000, rating: 90, tags: ['Singleplayer', 'Multiplayer', 'Open World', '3D', 'Story Rich', 'Realistic'] },
            '582010': { name: 'Monster Hunter: World', owners: 7000000, rating: 88, tags: ['Singleplayer', 'Co-op', 'Multiplayer', '3D', 'Loot', 'Crafting'] },
            '1158310': { name: 'Crusader Kings III', owners: 3000000, rating: 92, tags: ['Singleplayer', 'Multiplayer', '3D', 'Story Rich'] },
            '289070': { name: 'Civilization VI', owners: 12000000, rating: 81, tags: ['Singleplayer', 'Multiplayer', 'Turn-Based', '3D'] },
            '281990': { name: 'Stellaris', owners: 5000000, rating: 88, tags: ['Singleplayer', 'Multiplayer', '3D', 'Procedural'] },
            '1062090': { name: 'Stardew Valley', owners: 20000000, rating: 97, tags: ['Singleplayer', 'Co-op', 'Indie', '2D', 'Pixel Graphics', 'Relaxing', 'Crafting'] },
            '255710': { name: 'Cities: Skylines', owners: 12000000, rating: 93, tags: ['Singleplayer', '3D', 'Building', 'Relaxing'] },
            '313210': { name: 'Oxygen Not Included', owners: 3000000, rating: 96, tags: ['Singleplayer', 'Indie', '2D', 'Building', 'Difficult'] },
            '892970': { name: 'Valheim', owners: 12000000, rating: 95, tags: ['Multiplayer', 'Co-op', 'Online', 'Open World', '3D', 'Crafting', 'Building', 'Early Access'] },
            '252490': { name: 'Rust', owners: 14000000, rating: 85, tags: ['Multiplayer', 'PvP', 'Online', 'Open World', '3D', 'Crafting', 'Building'] },
            '346110': { name: 'ARK: Survival Evolved', owners: 20000000, rating: 78, tags: ['Multiplayer', 'Co-op', 'PvP', 'Open World', '3D', 'Crafting', 'Building'] },
            '1623730': { name: 'Palworld', owners: 15000000, rating: 83, tags: ['Singleplayer', 'Multiplayer', 'Co-op', 'Open World', '3D', 'Crafting', 'Building', 'Early Access'] },
            '1149460': { name: 'Sons Of The Forest', owners: 5000000, rating: 85, tags: ['Singleplayer', 'Co-op', 'Open World', '3D', 'Crafting', 'Building', 'Early Access'] },
            '105600': { name: 'Terraria', owners: 40000000, rating: 97, tags: ['Singleplayer', 'Co-op', 'Multiplayer', '2D', 'Pixel Graphics', 'Crafting', 'Building', 'Procedural'] },
            '264710': { name: 'Subnautica', owners: 8000000, rating: 96, tags: ['Singleplayer', 'Open World', '3D', 'Crafting', 'Story Rich', 'Atmospheric'] },
            '367520': { name: 'Hollow Knight', owners: 6000000, rating: 96, tags: ['Singleplayer', 'Indie', '2D', 'Difficult', 'Atmospheric', 'Controller'] }
        };

        function getDummyGames(genre, sortBy) {
            // 장르별 게임 appid 매핑
            const genreGameIds = {
                shooter: ['578080', '1172470', '359550', '730', '1938090', '271590', '594650', '1966720'],
                battle_royale: ['578080', '1172470', '1938090'],
                roguelite: ['1145360', '2379780', '1794680', '311690', '851730', '588650', '646570'],
                rpg: ['1245620', '1091500', '292030', '374320', '1174180', '582010'],
                action: ['1245620', '374320', '588650', '1145360', '367520'],
                strategy: ['1158310', '289070', '281990'],
                simulation: ['1062090', '255710', '313210'],
                survival: ['892970', '252490', '346110', '1623730', '1149460', '105600', '264710'],
                horror: ['594650', '1149460', '1966720'],
                puzzle: ['313210'],
                platformer: ['367520', '588650'],
                sandbox: ['105600', '255710', '892970', '346110'],
                card_game: ['646570', '2379780'],
                idle: ['1794680']
            };

            const gameIds = genreGameIds[genre] || genreGameIds.shooter;
            let games = gameIds.map(id => ({
                appid: id,
                ...gamesWithTags[id]
            })).filter(g => g.name);

            // 태그 필터 적용
            if (state.tags.length > 0) {
                games = games.filter(game => {
                    return state.tags.every(tag => game.tags?.includes(tag));
                });
            }

            // 정렬
            switch (sortBy) {
                case 'popular':
                    games.sort((a, b) => b.owners - a.owners);
                    break;
                case 'rating':
                    games.sort((a, b) => b.rating - a.rating);
                    break;
                case 'recent':
                    games = [...games].sort(() => Math.random() - 0.5);
                    break;
            }

            return games.slice(0, 10);
        }

        function renderReferenceGames(games) {
            const listEl = document.getElementById('refList');
            
            games.forEach(game => {
                const isSelected = state.selectedRefs.some(r => r.appid === game.appid);
                const item = document.createElement('div');
                item.className = `ref-item ${isSelected ? 'selected' : ''}`;
                item.dataset.appid = game.appid;
                item.innerHTML = `
                    <div class="ref-checkbox">${isSelected ? '✓' : ''}</div>
                    <div class="ref-info">
                        <div class="ref-name">${game.name}</div>
                        <div class="ref-meta">
                            <span>${formatOwners(game.owners)} owners</span>
                            <span>${game.rating.toFixed(0)}% 긍정적</span>
                        </div>
                    </div>
                `;
                item.addEventListener('click', () => toggleRefSelection(game, item));
                listEl.appendChild(item);
            });
        }

        function formatOwners(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
            return num;
        }

        function toggleRefSelection(game, element) {
            const index = state.selectedRefs.findIndex(r => r.appid === game.appid);
            
            if (index > -1) {
                state.selectedRefs.splice(index, 1);
                element.classList.remove('selected');
                element.querySelector('.ref-checkbox').textContent = '';
            } else {
                state.selectedRefs.push(game);
                element.classList.add('selected');
                element.querySelector('.ref-checkbox').textContent = '✓';
            }

            updateSelectedRefCount();
        }

        function updateSelectedRefCount() {
            document.getElementById('selectedRefCount').textContent = state.selectedRefs.length;
            renderSelectedGamesList();
        }

        function renderSelectedGamesList() {
            const listEl = document.getElementById('selectedGamesList');
            const itemsEl = document.getElementById('selectedGamesItems');
            
            if (state.selectedRefs.length === 0) {
                listEl.style.display = 'none';
                return;
            }
            
            listEl.style.display = 'block';
            itemsEl.innerHTML = state.selectedRefs.map(ref => `
                <div class="selected-game-chip">
                    <span>${escapeHtml(ref.name)}</span>
                    <button class="selected-game-remove" onclick="removeSelectedGame('${ref.appid}')" title="제거">×</button>
                </div>
            `).join('');
        }

        function removeSelectedGame(appid) {
            state.selectedRefs = state.selectedRefs.filter(r => r.appid !== appid);
            updateSelectedRefCount();
            
            // 추천 리스트에서 해당 게임 UI도 업데이트
            if (state.genres.length > 0 || state.tags.length > 0) {
                loadReferenceGames();
            }
        }

        function clearSelectedGames() {
            state.selectedRefs = [];
            updateSelectedRefCount();
            
            if (state.genres.length > 0 || state.tags.length > 0) {
                loadReferenceGames();
            }
        }

        function clearAllFilters() {
            // 장르 초기화
            state.genres = [];
            document.querySelectorAll('.genre-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // 태그 초기화
            state.tags = [];
            document.querySelectorAll('.tag-filter-btn').forEach(btn => {
                btn.classList.remove('selected');
                btn.querySelector('.tag-remove')?.remove();
            });
            
            updateGenreCount();
            clearReferenceList();
        }

        // ===== 분석 실행 =====
        async function startAnalysis() {
            // 유효성 검사
            if (!state.idea.trim()) {
                showToast('아이디어를 입력해주세요', 'warning');
                return;
            }
            if (state.genres.length === 0) {
                showToast('장르를 최소 1개 선택해주세요', 'warning');
                return;
            }
            if (state.selectedRefs.length === 0) {
                showToast('Reference 게임을 최소 1개 선택해주세요', 'warning');
                return;
            }
            if (!state.apis.openai && !state.apis.anthropic && !state.apis.gemini && !state.apis.vertex) {
                showToast('API 키를 설정해주세요', 'warning');
                openSettingsModal();
                return;
            }

            // 분석 시작 - 첫 단계로 이동
            state.currentStep = 1;

            log('info', '=== 분석 시작 ===');
            log('info', `아이디어: <span class="highlight">${state.idea.substring(0, 50)}...</span>`);
            log('info', `장르: <code>${state.genres.join(', ')}</code>`);
            log('info', `태그 필터: <code>${state.tags.length > 0 ? state.tags.join(', ') : '없음'}</code>`);
            log('info', `Reference 게임: <code>${state.selectedRefs.map(r => r.name).join(', ')}</code>`);
            log('info', `프리셋: <code>${state.preset}</code> (${presetConfig[state.preset].reviewsPerGame}개/게임)`);

            // UI 업데이트
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = '분석 중...';

            try {
                // Step 1: 리뷰 수집
                await runStep(1, '리뷰 수집', collectReviews);
                
                // Step 2: 태깅
                await runStep(2, '태깅', tagReviews);
                
                // Step 3: 페르소나
                await runStep(3, '페르소나', generatePersonas);
                
                // Step 4: 검증
                await runStep(4, '검증', validateIdea);
                
                // Step 5: 리포트
                await runStep(5, '리포트', generateReport);

                log('success', '=== 분석 완료 ===');
                log('info', `총 토큰 사용량: <span class="highlight">${state.totalTokens.toLocaleString()}</span>`);
                showToast('분석이 완료되었습니다!', 'success');
            } catch (error) {
                log('error', `분석 실패: ${error.message}`);
                console.error('Analysis failed:', error);
                showToast('분석 중 오류가 발생했습니다: ' + error.message, 'error');
            } finally {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('startBtn').textContent = '분석 시작';
            }
        }

        async function runStep(stepNum, stepName, stepFn) {
            // 해당 뷰로 전환
            switchToView(stepNum);
            
            // 진행중 상태 표시
            updatePipelineStep(stepNum, 'active', '진행중...');
            state.currentStep = stepNum;
            updateProgress();
            
            // 로딩 UI 표시 (로그 패널 유지)
            const contentEl = document.getElementById(`step${stepNum}Content`);
            const mainContent = contentEl.querySelector('.step-main-content');
            if (mainContent) {
                mainContent.innerHTML = `
                    <div class="step-running">
                        <div class="spinner-lg"></div>
                        <div class="step-running-text">${stepName} 진행중...</div>
                    </div>
                `;
            } else {
                // 로그 패널 HTML 저장
                const logPanelHtml = getStepLogPanelHtml(stepNum);
                contentEl.innerHTML = `
                    <div class="step-main-content">
                        <div class="step-running">
                            <div class="spinner-lg"></div>
                            <div class="step-running-text">${stepName} 진행중...</div>
                        </div>
                    </div>
                    ${logPanelHtml}
                `;
            }

            try {
                const result = await stepFn();
                state.results[`step${stepNum}`] = result;
                updatePipelineStep(stepNum, 'completed', '완료');
                renderStepResult(stepNum, result);
            } catch (error) {
                updatePipelineStep(stepNum, 'active', '오류');
                const mainContent = contentEl.querySelector('.step-main-content');
                if (mainContent) {
                    mainContent.innerHTML = `
                        <div class="step-pending">
                            <div class="step-pending-icon" style="border-color: var(--accent-danger); color: var(--accent-danger);">!</div>
                            <div class="step-pending-text" style="color: var(--accent-danger);">오류 발생: ${error.message}</div>
                        </div>
                    `;
                }
                throw error;
            }
        }

        function getStepLogPanelHtml(stepNum) {
            return `
                <div class="step-log-panel collapsed" id="step${stepNum}LogPanel">
                    <div class="step-log-header" onclick="toggleStepLog(${stepNum})">
                        <div class="step-log-title">
                            <span class="step-log-toggle">▶</span>
                            <span>🔍 분석 과정 보기</span>
                            <span class="log-badge" id="step${stepNum}LogBadge">0</span>
                        </div>
                    </div>
                    <div class="step-log-content" id="step${stepNum}LogContent">
                        <div class="step-log-empty">분석 과정이 기록됩니다</div>
                        <div class="log-entries" id="step${stepNum}LogEntries"></div>
                    </div>
                </div>
            `;
        }

        function updatePipelineStep(stepNum, status, desc) {
            const step = document.querySelector(`.pipeline-step[data-step="${stepNum}"]`);
            step.className = `pipeline-step ${status}`;
            step.querySelector('.step-desc').textContent = desc;
            
            if (status === 'completed') {
                step.querySelector('.step-icon').textContent = '✓';
            } else if (status === 'active') {
                step.querySelector('.step-icon').textContent = stepNum;
            }
        }

        function updateProgress() {
            const percent = (state.currentStep / 5) * 100;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('stepCount').textContent = `${state.currentStep}/5`;
            document.getElementById('tokenCount').textContent = state.totalTokens.toLocaleString();
        }

        // ===== CORS 프록시 헬퍼 =====
        const CORS_PROXIES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            (url) => `https://thingproxy.freeboard.io/fetch/${url}`
        ];

        async function fetchWithProxy(url, options = {}) {
            let lastError = null;
            
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxyUrl = CORS_PROXIES[i](url);
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15초 타임아웃
                    
                    const response = await fetch(proxyUrl, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    return response;
                } catch (err) {
                    lastError = err;
                    console.warn(`Proxy ${i + 1} failed:`, err.message);
                    // 다음 프록시 시도
                }
            }
            
            throw lastError || new Error('All proxies failed');
        }

        // ===== LLM API 호출 헬퍼 =====
        async function callLLM(messages, options = {}) {
            const { temperature = 0.7, max_tokens = 2000 } = options;
            
            // OpenAI 우선
            if (state.apis.openai) {
                return await callOpenAI(messages, temperature, max_tokens);
            }
            // Anthropic (브라우저에서 직접 호출 불가 - CORS 제한)
            if (state.apis.anthropic) {
                throw new Error('Anthropic API는 브라우저에서 직접 호출할 수 없습니다. OpenAI API 키를 사용해주세요.');
            }
            throw new Error('API 키가 설정되지 않았습니다. 설정에서 OpenAI API 키를 입력해주세요.');
        }

        async function callOpenAI(messages, temperature, max_tokens, retries = 2) {
            let response;
            let lastError;
            
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 45000); // 45초 타임아웃
                    
                    if (attempt > 0) {
                        log('info', `재시도 ${attempt}/${retries}...`);
                    }
                    
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${state.apis.openai}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: messages,
                            temperature: temperature,
                            max_tokens: max_tokens
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    break; // 성공하면 루프 종료
                    
                } catch (err) {
                    lastError = err;
                    if (err.name === 'AbortError') {
                        lastError = new Error(`API 응답 시간 초과 (45초)`);
                    } else {
                        lastError = new Error(`API 연결 실패`);
                    }
                    
                    if (attempt < retries) {
                        await new Promise(r => setTimeout(r, 2000)); // 2초 대기 후 재시도
                    }
                }
            }
            
            if (!response) {
                throw lastError;
            }
            
            if (!response.ok) {
                let errMsg = 'OpenAI API 오류';
                try {
                    const err = await response.json();
                    errMsg = err.error?.message || errMsg;
                } catch {}
                
                if (response.status === 401) {
                    throw new Error('OpenAI API 키가 유효하지 않습니다');
                } else if (response.status === 429) {
                    throw new Error('OpenAI API 요청 한도 초과 (잠시 후 재시도)');
                } else if (response.status === 403) {
                    throw new Error('OpenAI API 접근 거부됨 (API 키 권한 확인)');
                }
                throw new Error(errMsg);
            }
            
            // 응답 파싱에도 타임아웃 적용
            let data;
            try {
                const parsePromise = response.json();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('응답 파싱 시간 초과')), 10000)
                );
                data = await Promise.race([parsePromise, timeoutPromise]);
            } catch (err) {
                throw new Error(`응답 처리 실패: ${err.message}`);
            }
            const usage = data.usage || {};
            
            // 토큰 추적
            const tokensUsed = (usage.prompt_tokens || 0) + (usage.completion_tokens || 0);
            state.totalTokens += tokensUsed;
            state.tokenDetails.push({
                step: state.currentStep,
                input: usage.prompt_tokens || 0,
                output: usage.completion_tokens || 0,
                model: 'gpt-4o-mini'
            });
            updateTokenDisplay();
            
            return {
                content: data.choices[0].message.content,
                tokens: tokensUsed
            };
        }

        async function callAnthropic(messages, temperature, max_tokens) {
            // Anthropic은 CORS 문제로 직접 호출 어려움 - 프록시 필요
            // 여기서는 OpenAI 형태로 변환
            const systemMsg = messages.find(m => m.role === 'system')?.content || '';
            const userMsgs = messages.filter(m => m.role !== 'system');
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': state.apis.anthropic,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-3-haiku-20240307',
                    max_tokens: max_tokens,
                    system: systemMsg,
                    messages: userMsgs.map(m => ({ role: m.role, content: m.content }))
                })
            });
            
            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error?.message || 'Anthropic API 오류');
            }
            
            const data = await response.json();
            const usage = data.usage || {};
            
            const tokensUsed = (usage.input_tokens || 0) + (usage.output_tokens || 0);
            state.totalTokens += tokensUsed;
            state.tokenDetails.push({
                step: state.currentStep,
                input: usage.input_tokens || 0,
                output: usage.output_tokens || 0,
                model: 'claude-3-haiku'
            });
            updateTokenDisplay();
            
            return {
                content: data.content[0].text,
                tokens: tokensUsed
            };
        }

        function updateTokenDisplay() {
            document.getElementById('tokenCount').textContent = state.totalTokens.toLocaleString();
            // 비용 계산 (GPT-4o-mini 기준: $0.15/1M input, $0.60/1M output)
            const cost = (state.totalTokens / 1000000) * 0.30; // 평균
            document.getElementById('footerTokens').textContent = `${state.totalTokens.toLocaleString()} tokens`;
            document.getElementById('footerCost').textContent = `$${cost.toFixed(4)}`;
        }

        // ===== 각 단계별 함수 =====
        async function collectReviews() {
            const reviewsPerGame = presetConfig[state.preset].reviewsPerGame;
            const allReviews = [];
            const gameStats = [];
            
            log('step', `[Step 1] 리뷰 수집 시작`);
            
            for (const game of state.selectedRefs) {
                log('api', `Steam API 호출: <code>${game.name}</code> (AppID: ${game.appid})`);
                
                try {
                    // Steam API (CORS 프록시 사용)
                    const steamUrl = `https://store.steampowered.com/appreviews/${game.appid}?json=1&num_per_page=${reviewsPerGame}&language=all&purchase_type=all`;
                    
                    const response = await fetchWithProxy(steamUrl);
                    const data = await response.json();
                    
                    if (data.success && data.reviews) {
                        const reviews = data.reviews.map(r => ({
                            game: game.name,
                            appid: game.appid,
                            text: r.review,
                            voted_up: r.voted_up,
                            playtime: r.author.playtime_forever,
                            timestamp: r.timestamp_created
                        }));
                        
                        const positiveCount = reviews.filter(r => r.voted_up).length;
                        const negativeCount = reviews.length - positiveCount;
                        
                        gameStats.push({
                            name: game.name,
                            appid: game.appid,
                            totalReviews: reviews.length,
                            positive: positiveCount,
                            negative: negativeCount,
                            positiveRate: reviews.length > 0 ? Math.round((positiveCount / reviews.length) * 100) : 0
                        });
                        
                        allReviews.push(...reviews);
                        log('success', `${game.name}: <span class="highlight">${reviews.length}개</span> (긍정 ${positiveCount} / 부정 ${negativeCount})`);
                    } else {
                        log('error', `${game.name}: 리뷰 수집 실패`);
                        gameStats.push({ name: game.name, appid: game.appid, totalReviews: 0, positive: 0, negative: 0, positiveRate: 0 });
                    }
                } catch (err) {
                    log('error', `${game.name}: ${err.message}`);
                    gameStats.push({ name: game.name, appid: game.appid, totalReviews: 0, positive: 0, negative: 0, positiveRate: 0 });
                }
                
                await delay(300); // Rate limiting
            }

            const totalPositive = gameStats.reduce((sum, g) => sum + g.positive, 0);
            const totalNegative = gameStats.reduce((sum, g) => sum + g.negative, 0);
            
            log('success', `총 <span class="highlight">${allReviews.length}개</span> 리뷰 수집 완료 (긍정 ${totalPositive} / 부정 ${totalNegative})`);
            
            return { 
                reviews: allReviews, 
                count: allReviews.length,
                gameStats: gameStats,
                totalPositive,
                totalNegative
            };
        }

        async function tagReviews() {
            log('step', `[Step 2] 리뷰 태깅 시작`);
            
            const reviews = state.results.step1?.reviews || [];
            if (reviews.length === 0) {
                throw new Error('분석할 리뷰가 없습니다');
            }
            
            // 리뷰 텍스트 샘플링 (너무 많으면 일부만)
            const sampleSize = Math.min(reviews.length, 50);
            const sampledReviews = reviews.slice(0, sampleSize);
            
            const reviewTexts = sampledReviews.map((r, i) => 
                `[${i+1}] ${r.voted_up ? '👍' : '👎'} ${r.text.substring(0, 300)}${r.text.length > 300 ? '...' : ''}`
            ).join('\n\n');
            
            log('api', `LLM API 호출 (${sampleSize}개 리뷰 분석)`);
            
            const prompt = `다음은 게임 리뷰들입니다. 이 리뷰들을 분석하여 공통적인 Pain Point(불만 사항)와 Delight Point(만족 사항)를 태그로 추출해주세요.

[리뷰 목록]
${reviewTexts}

다음 JSON 형식으로만 응답해주세요:
{
  "pain": [
    { "tag": "태그명", "count": 언급횟수, "description": "간단한 설명" }
  ],
  "delight": [
    { "tag": "태그명", "count": 언급횟수, "description": "간단한 설명" }
  ],
  "summary": "전체 리뷰 분석 요약 (2-3문장)"
}

각 카테고리당 상위 5-7개 태그만 추출하세요.`;

            try {
                const response = await callLLM([
                    { role: 'system', content: '당신은 게임 리뷰 분석 전문가입니다. JSON 형식으로만 응답하세요.' },
                    { role: 'user', content: prompt }
                ], { temperature: 0.3, max_tokens: 1500 });
                
                log('info', `토큰 사용: <span class="highlight">+${response.tokens.toLocaleString()}</span>`);
                
                // JSON 파싱
                let parsed;
                try {
                    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                    parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                } catch (e) {
                    log('error', 'JSON 파싱 실패, 기본 결과 사용');
                    parsed = { pain: [], delight: [], summary: '파싱 실패' };
                }
                
                // percent 계산
                const totalReviews = reviews.length;
                const painTags = (parsed.pain || []).map(t => ({
                    ...t,
                    percent: Math.round((t.count / sampleSize) * 100)
                }));
                const delightTags = (parsed.delight || []).map(t => ({
                    ...t,
                    percent: Math.round((t.count / sampleSize) * 100)
                }));
                
                log('success', `태깅 완료 - Pain: ${painTags.length}개, Delight: ${delightTags.length}개`);
                
                return {
                    tags: { pain: painTags, delight: delightTags },
                    summary: parsed.summary || '',
                    analyzedCount: sampleSize,
                    totalCount: totalReviews
                };
            } catch (err) {
                log('error', `태깅 실패: ${err.message}`);
                throw err;
            }
        }

        async function generatePersonas() {
            log('step', `[Step 3] 페르소나 생성 시작`);
            
            const tags = state.results.step2?.tags;
            const summary = state.results.step2?.summary || '';
            
            const painList = tags?.pain.map(t => `${t.tag}(${t.percent}%): ${t.description || ''}`).join('\n') || '없음';
            const delightList = tags?.delight.map(t => `${t.tag}(${t.percent}%): ${t.description || ''}`).join('\n') || '없음';
            
            log('api', `LLM API 호출 - 페르소나 생성`);
            
            // 사용자 컨텍스트 추가
            const userContextStr = (state.userContexts && state.userContexts.length > 0) 
                ? `\n[사용자 추가 지시사항]\n${state.userContexts.join('\n')}\n`
                : '';
            
            const prompt = `당신은 게임 기획 전문가입니다. 다음 정보를 바탕으로 타겟 유저 페르소나를 생성해주세요.

[검증할 아이디어]
${state.idea}

[타겟 장르]
${state.genres.join(', ')}

[리뷰 분석 결과 - Pain Points]
${painList}

[리뷰 분석 결과 - Delight Points]  
${delightList}

[리뷰 분석 요약]
${summary}
${userContextStr}
위 정보를 바탕으로 이 아이디어의 잠재 타겟 유저 4명의 페르소나를 생성해주세요.

다음 JSON 형식으로만 응답:
{
  "personas": [
    {
      "name": "페르소나 이름 (예: 스피드런 캐주얼러)",
      "type": "유저 유형 (예: Casual · Short Session)",
      "description": "이 페르소나에 대한 2-3문장 설명",
      "goals": ["목표1", "목표2", "목표3"],
      "pains": ["고통점1", "고통점2"],
      "triggers": ["이탈 트리거1", "이탈 트리거2"],
      "fit_score": 1-10점 (이 아이디어와의 적합도)
    }
  ],
  "primary_target": "가장 중요한 타겟 페르소나 이름",
  "reasoning": "왜 이 페르소나들이 타겟인지 설명"
}`;

            try {
                const response = await callLLM([
                    { role: 'system', content: '당신은 게임 유저 분석 전문가입니다. JSON 형식으로만 응답하세요.' },
                    { role: 'user', content: prompt }
                ], { temperature: 0.7, max_tokens: 2000 });
                
                log('info', `토큰 사용: <span class="highlight">+${response.tokens.toLocaleString()}</span>`);
                
                let parsed;
                try {
                    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                    parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                } catch (e) {
                    log('error', 'JSON 파싱 실패');
                    throw new Error('페르소나 생성 결과 파싱 실패');
                }
                
                // rank 추가 (fit_score 기준 정렬)
                const personas = (parsed.personas || [])
                    .sort((a, b) => (b.fit_score || 0) - (a.fit_score || 0))
                    .map((p, i) => ({ ...p, rank: i + 1 }));
                
                log('success', `${personas.length}개 페르소나 생성 완료`);
                
                log('success', `${personas.length}개 페르소나 생성 완료`);
                personas.forEach((p, i) => {
                    log('info', `  ${i+1}. <span class="highlight">${p.name}</span> (${p.type}) - 적합도 ${p.fit_score || '?'}/10`);
                });
                
                return {
                    personas: personas,
                    primaryTarget: parsed.primary_target,
                    reasoning: parsed.reasoning
                };
            } catch (err) {
                log('error', `페르소나 생성 실패: ${err.message}`);
                throw err;
            }
        }

        async function validateIdea() {
            log('step', `[Step 4] 아이디어 검증 시작`);
            
            const personas = state.results.step3?.personas || [];
            const tags = state.results.step2?.tags || { pain: [], delight: [] };
            
            const personaList = personas.map(p => 
                `- ${p.name} (${p.type}): 목표[${p.goals.join(', ')}], 고통점[${p.pains.join(', ')}], 이탈트리거[${p.triggers.join(', ')}]`
            ).join('\n');
            
            log('api', `LLM API 호출 - 리스크 분석`);
            
            const prompt = `당신은 게임 기획 검토 전문가입니다. 다음 아이디어에 대한 리스크를 분석해주세요.

[아이디어]
${state.idea}

[타겟 장르]
${state.genres.join(', ')}

[분석된 Pain Points]
${tags.pain.map(t => `- ${t.tag}: ${t.description || ''}`).join('\n')}

[분석된 Delight Points]
${tags.delight.map(t => `- ${t.tag}: ${t.description || ''}`).join('\n')}

[타겟 페르소나]
${personaList}

위 정보를 바탕으로 이 아이디어의 잠재적 리스크를 분석해주세요.

다음 JSON 형식으로만 응답:
{
  "risks": [
    {
      "title": "리스크 제목",
      "description": "상세 설명",
      "category": "BALANCE|UX|TECH|EXECUTION|OPS 중 하나",
      "severity": "high|medium|low",
      "affected_personas": ["영향받는 페르소나 이름"],
      "mitigation": "완화 방안"
    }
  ],
  "overall_assessment": "전체 평가 (2-3문장)",
  "go_no_go": "GO|GO_WITH_CAUTION|PIVOT|NO_GO",
  "confidence_score": 1-100
}`;

            try {
                const response = await callLLM([
                    { role: 'system', content: '당신은 게임 기획 리스크 분석 전문가입니다. JSON 형식으로만 응답하세요.' },
                    { role: 'user', content: prompt }
                ], { temperature: 0.3, max_tokens: 2000 });
                
                log('info', `토큰 사용: <span class="highlight">+${response.tokens.toLocaleString()}</span>`);
                
                let parsed;
                try {
                    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                    parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                } catch (e) {
                    log('error', 'JSON 파싱 실패');
                    throw new Error('리스크 분석 결과 파싱 실패');
                }
                
                const risks = parsed.risks || [];
                const highCount = risks.filter(r => r.severity === 'high').length;
                const medCount = risks.filter(r => r.severity === 'medium').length;
                
                log('success', `리스크 ${risks.length}개 식별 완료`);
                log('info', `  🔴 High: ${highCount}개, 🟡 Medium: ${medCount}개, 🟢 Low: ${risks.length - highCount - medCount}개`);
                
                return {
                    risks: risks,
                    assessment: parsed.overall_assessment,
                    recommendation: parsed.go_no_go || 'GO_WITH_CAUTION',
                    score: parsed.confidence_score || 50
                };
            } catch (err) {
                log('error', `리스크 분석 실패: ${err.message}`);
                throw err;
            }
        }

        async function generateReport() {
            log('step', `[Step 5] 최종 리포트 생성`);
            
            const step1 = state.results.step1 || {};
            const step2 = state.results.step2 || {};
            const step3 = state.results.step3 || {};
            const step4 = state.results.step4 || {};
            
            log('api', `LLM API 호출 - 최종 리포트`);
            
            const prompt = `다음 분석 결과를 바탕으로 최종 검증 리포트를 작성해주세요.

[검증 아이디어]
${state.idea}

[분석 결과 요약]
- 수집된 리뷰: ${step1.count || 0}개 (긍정 ${step1.totalPositive || 0} / 부정 ${step1.totalNegative || 0})
- 주요 Pain Points: ${step2.tags?.pain?.map(t => t.tag).join(', ') || '없음'}
- 주요 Delight Points: ${step2.tags?.delight?.map(t => t.tag).join(', ') || '없음'}
- 타겟 페르소나: ${step3.personas?.map(p => p.name).join(', ') || '없음'}
- 식별된 리스크: ${step4.risks?.length || 0}개 (High: ${step4.risks?.filter(r => r.severity === 'high').length || 0})

[리스크 상세]
${step4.risks?.map(r => `- [${r.severity.toUpperCase()}] ${r.title}: ${r.mitigation}`).join('\n') || '없음'}

다음 JSON 형식으로 최종 리포트를 작성해주세요:
{
  "executive_summary": "핵심 요약 (3-4문장)",
  "strengths": ["강점1", "강점2", "강점3"],
  "weaknesses": ["약점1", "약점2"],
  "opportunities": ["기회1", "기회2"],
  "threats": ["위협1", "위협2"],
  "recommendation": "GO|GO_WITH_CAUTION|PIVOT|NO_GO",
  "final_score": 1-100,
  "next_steps": ["다음 단계1", "다음 단계2", "다음 단계3"],
  "key_success_factors": ["성공 요인1", "성공 요인2"]
}`;

            try {
                const response = await callLLM([
                    { role: 'system', content: '당신은 게임 기획 컨설턴트입니다. JSON 형식으로만 응답하세요.' },
                    { role: 'user', content: prompt }
                ], { temperature: 0.2, max_tokens: 1500 });
                
                log('info', `토큰 사용: <span class="highlight">+${response.tokens.toLocaleString()}</span>`);
                
                let parsed;
                try {
                    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                    parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                } catch (e) {
                    log('error', 'JSON 파싱 실패');
                    parsed = { executive_summary: '리포트 생성 실패', final_score: 0, recommendation: 'NO_GO' };
                }
                
                log('success', `최종 점수: <span class="highlight">${parsed.final_score}점</span> - ${parsed.recommendation}`);
                
                return {
                    summary: parsed.executive_summary,
                    strengths: parsed.strengths || [],
                    weaknesses: parsed.weaknesses || [],
                    opportunities: parsed.opportunities || [],
                    threats: parsed.threats || [],
                    recommendation: parsed.recommendation || 'GO_WITH_CAUTION',
                    score: parsed.final_score || 50,
                    nextSteps: parsed.next_steps || [],
                    successFactors: parsed.key_success_factors || []
                };
            } catch (err) {
                log('error', `리포트 생성 실패: ${err.message}`);
                throw err;
            }
        }

        function getActiveModel() {
            if (state.apis.openai) return 'gpt-4o-mini';
            if (state.apis.anthropic) return 'claude-3-haiku';
            if (state.apis.vertex) return 'vertex-claude-3.5';
            if (state.apis.gemini) return 'gemini-1.5-flash';
            return 'unknown';
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ===== 결과 렌더링 =====
        function renderStepResult(stepNum, result) {
            const contentEl = document.getElementById(`step${stepNum}Content`);
            let mainContent = contentEl.querySelector('.step-main-content');
            
            // main content가 없으면 생성
            if (!mainContent) {
                const logPanelHtml = getStepLogPanelHtml(stepNum);
                contentEl.innerHTML = `<div class="step-main-content"></div>${logPanelHtml}`;
                mainContent = contentEl.querySelector('.step-main-content');
            }
            
            switch (stepNum) {
                case 1:
                    mainContent.innerHTML = renderReviewsResult(result);
                    break;
                case 2:
                    mainContent.innerHTML = renderTagsResult(result);
                    break;
                case 3:
                    mainContent.innerHTML = renderPersonasResult(result);
                    break;
                case 4:
                    mainContent.innerHTML = renderRisksResult(result);
                    break;
                case 5:
                    mainContent.innerHTML = renderReportResult(result);
                    document.getElementById('footerInfo').textContent = 
                        `${result.score}점 · ${state.results.step3.personas.length}개 페르소나 · ${state.results.step4.risks.length}개 리스크`;
                    break;
            }
        }

        function renderReviewsResult(result) {
            const gameStats = result.gameStats || [];
            const totalPositive = result.totalPositive || 0;
            const totalNegative = result.totalNegative || 0;
            const positiveRate = result.count > 0 ? Math.round((totalPositive / result.count) * 100) : 0;
            
            return `
                <div class="review-summary">
                    <div class="summary-stat-grid">
                        <div class="summary-stat">
                            <div class="summary-stat-value">${result.count}</div>
                            <div class="summary-stat-label">총 리뷰 수</div>
                        </div>
                        <div class="summary-stat positive">
                            <div class="summary-stat-value">👍 ${totalPositive}</div>
                            <div class="summary-stat-label">긍정 리뷰 (${positiveRate}%)</div>
                        </div>
                        <div class="summary-stat negative">
                            <div class="summary-stat-value">👎 ${totalNegative}</div>
                            <div class="summary-stat-label">부정 리뷰 (${100 - positiveRate}%)</div>
                        </div>
                    </div>
                    <div class="review-game-list">
                        <h4>게임별 수집 현황</h4>
                        ${gameStats.map(g => `
                            <div class="review-game-item">
                                <span class="review-game-name">${g.name}</span>
                                <div class="review-game-stats">
                                    <span class="review-count">${g.totalReviews}개</span>
                                    <span class="review-positive">👍 ${g.positive}</span>
                                    <span class="review-negative">👎 ${g.negative}</span>
                                    <span class="review-rate ${g.positiveRate >= 70 ? 'good' : g.positiveRate >= 40 ? 'mixed' : 'bad'}">${g.positiveRate}%</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    ${result.reviews?.length > 0 ? `
                    <div class="review-samples">
                        <h4>리뷰 샘플 (최근 5개)</h4>
                        ${result.reviews.slice(0, 5).map(r => `
                            <div class="review-sample-item ${r.voted_up ? 'positive' : 'negative'}">
                                <div class="review-sample-header">
                                    <span class="review-vote">${r.voted_up ? '👍' : '👎'}</span>
                                    <span class="review-game-tag">${r.game}</span>
                                </div>
                                <div class="review-sample-text">${(r.text || '').substring(0, 200)}${(r.text || '').length > 200 ? '...' : ''}</div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                </div>
            `;
        }

        function renderTagsResult(result) {
            const { tags, summary, analyzedCount, totalCount } = result;
            let html = `
                <div class="tag-result">
                    <div class="tag-summary-box">
                        <div class="tag-summary-header">
                            <span class="tag-summary-title">📊 리뷰 분석 요약</span>
                            <span class="tag-summary-count">${analyzedCount || 0}개 리뷰 분석</span>
                        </div>
                        <p class="tag-summary-text">${summary || '분석 요약을 가져올 수 없습니다.'}</p>
                    </div>
                    
                    <div class="tag-sections">
                        <div class="tag-section pain-section">
                            <h4 class="tag-section-title">😤 Pain Points (불만 요소)</h4>
                            <div class="tag-distribution">`;

            (tags?.pain || []).forEach(t => {
                html += `
                    <div class="dist-item">
                        <div class="dist-header">
                            <span class="dist-label">${t.tag}</span>
                            <span class="dist-value pain">${t.count || 0}건 (${t.percent}%)</span>
                        </div>
                        <div class="dist-bar"><div class="dist-bar-fill pain" style="width: ${Math.min(t.percent, 100)}%"></div></div>
                        ${t.description ? `<div class="dist-description">${t.description}</div>` : ''}
                    </div>
                `;
            });

            html += `
                            </div>
                        </div>
                        
                        <div class="tag-section delight-section">
                            <h4 class="tag-section-title">😊 Delight Points (만족 요소)</h4>
                            <div class="tag-distribution">`;

            (tags?.delight || []).forEach(t => {
                html += `
                    <div class="dist-item">
                        <div class="dist-header">
                            <span class="dist-label">${t.tag}</span>
                            <span class="dist-value delight">${t.count || 0}건 (${t.percent}%)</span>
                        </div>
                        <div class="dist-bar"><div class="dist-bar-fill delight" style="width: ${Math.min(t.percent, 100)}%"></div></div>
                        ${t.description ? `<div class="dist-description">${t.description}</div>` : ''}
                    </div>
                `;
            });

            html += `
                            </div>
                        </div>
                    </div>
                </div>`;
            return html;
        }

        function renderPersonasResult(result) {
            const personas = result.personas || [];
            const primaryTarget = result.primaryTarget;
            const reasoning = result.reasoning;
            
            let html = `
                <div class="persona-result">
                    ${reasoning ? `
                    <div class="persona-reasoning-box">
                        <h4>🎯 타겟 분석 근거</h4>
                        <p>${reasoning}</p>
                        ${primaryTarget ? `<p><strong>주요 타겟:</strong> ${primaryTarget}</p>` : ''}
                    </div>
                    ` : ''}
                    <div class="persona-grid">`;

            personas.forEach(p => {
                const isTop = p.rank <= 2;
                const isPrimary = p.name === primaryTarget;
                const fitScore = p.fit_score || 0;
                const fitClass = fitScore >= 8 ? 'excellent' : fitScore >= 6 ? 'good' : fitScore >= 4 ? 'fair' : 'low';
                
                html += `
                    <div class="persona-card ${isTop ? 'top' : ''} ${isPrimary ? 'primary' : ''}">
                        <div class="persona-header">
                            <div class="persona-avatar">${p.name.charAt(0)}</div>
                            <div class="persona-meta">
                                <div class="persona-name">${p.name}</div>
                                <div class="persona-type">${p.type}</div>
                            </div>
                            <div class="persona-badges">
                                ${isPrimary ? `<span class="persona-badge primary">주요 타겟</span>` : ''}
                                ${isTop ? `<span class="persona-badge">TOP ${p.rank}</span>` : ''}
                                <span class="persona-fit ${fitClass}" title="아이디어 적합도">${fitScore}/10</span>
                            </div>
                        </div>
                        ${p.description ? `<p class="persona-description">${p.description}</p>` : ''}
                        <div class="persona-body">
                            <div class="persona-section">
                                <div class="persona-section-title">🎯 목표</div>
                                <div class="persona-list">
                                    ${(p.goals || []).map(g => `<span class="persona-tag goal">${g}</span>`).join('')}
                                </div>
                            </div>
                            <div class="persona-section">
                                <div class="persona-section-title">😤 고통점</div>
                                <div class="persona-list">
                                    ${(p.pains || []).map(g => `<span class="persona-tag pain">${g}</span>`).join('')}
                                </div>
                            </div>
                            <div class="persona-section">
                                <div class="persona-section-title">⚠️ 이탈 트리거</div>
                                <div class="persona-list">
                                    ${(p.triggers || []).map(g => `<span class="persona-tag trigger">${g}</span>`).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `</div></div>`;
            return html;
        }

        function renderRisksResult(result) {
            const risks = result.risks || [];
            const assessment = result.assessment;
            const highCount = risks.filter(r => r.severity === 'high').length;
            const medCount = risks.filter(r => r.severity === 'medium').length;
            const lowCount = risks.length - highCount - medCount;
            
            let html = `
                <div class="risk-result">
                    <div class="risk-summary-box">
                        <h4>📋 검증 결과 요약</h4>
                        ${assessment ? `<p>${assessment}</p>` : ''}
                        <div class="risk-counts">
                            <span class="risk-count high">🔴 High: ${highCount}</span>
                            <span class="risk-count medium">🟡 Medium: ${medCount}</span>
                            <span class="risk-count low">🟢 Low: ${lowCount}</span>
                        </div>
                    </div>
                    <div class="risk-list">`;

            risks.forEach(r => {
                const affectedPersonas = r.affected_personas || [];
                html += `
                    <div class="risk-item ${r.severity}">
                        <div class="risk-severity ${r.severity}"></div>
                        <div class="risk-content">
                            <div class="risk-header">
                                <div class="risk-title">${r.title}</div>
                                <span class="risk-category">${r.category}</span>
                            </div>
                            ${r.description ? `<div class="risk-description">${r.description}</div>` : ''}
                            ${affectedPersonas.length > 0 ? `
                                <div class="risk-affected">
                                    <span class="risk-affected-label">영향받는 페르소나:</span>
                                    ${affectedPersonas.map(p => `<span class="risk-affected-persona">${p}</span>`).join('')}
                                </div>
                            ` : ''}
                            <div class="risk-mitigation">
                                <span class="mitigation-label">💡 완화 방안:</span>
                                ${r.mitigation}
                            </div>
                        </div>
                    </div>
                `;
            });

            html += `</div></div>`;
            return html;
        }

        function renderReportResult(result) {
            const recText = {
                'GO': '✅ 진행 권장',
                'GO_WITH_CAUTION': '⚠️ 주의하며 진행',
                'PIVOT': '🔄 방향 전환 권장',
                'NO_GO': '❌ 진행 비권장'
            };
            const recClass = {
                'GO': 'success',
                'GO_WITH_CAUTION': 'warning',
                'PIVOT': 'warning',
                'NO_GO': 'danger'
            };
            
            const cost = (state.totalTokens / 1000000) * 0.30;

            return `
                <div class="report-full">
                    <!-- 상단: 점수 및 권장사항 -->
                    <div class="report-header-section">
                        <div class="report-score">
                            <div class="report-score-circle ${recClass[result.recommendation] || 'warning'}">
                                <span class="report-score-value">${result.score || 0}</span>
                                <span class="report-score-label">점</span>
                            </div>
                            <div class="report-recommendation ${recClass[result.recommendation] || 'warning'}">
                                ${recText[result.recommendation] || '평가 중'}
                            </div>
                        </div>
                        <div class="report-overview">
                            <div class="report-stat">
                                <div class="report-stat-label">분석된 리뷰</div>
                                <div class="report-stat-value">${state.results.step1?.count || 0}개</div>
                            </div>
                            <div class="report-stat">
                                <div class="report-stat-label">도출된 페르소나</div>
                                <div class="report-stat-value">${state.results.step3?.personas?.length || 0}개</div>
                            </div>
                            <div class="report-stat">
                                <div class="report-stat-label">식별된 리스크</div>
                                <div class="report-stat-value">${state.results.step4?.risks?.length || 0}개</div>
                            </div>
                            <div class="report-stat">
                                <div class="report-stat-label">사용된 토큰</div>
                                <div class="report-stat-value">${state.totalTokens.toLocaleString()} ($${cost.toFixed(4)})</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 핵심 요약 -->
                    <div class="report-executive-summary">
                        <h3>📋 핵심 요약</h3>
                        <p>${result.summary || '요약을 생성할 수 없습니다.'}</p>
                    </div>
                    
                    <!-- SWOT 분석 -->
                    <div class="report-swot">
                        <h3>📊 SWOT 분석</h3>
                        <div class="swot-grid">
                            <div class="swot-item strengths">
                                <h4>💪 강점 (Strengths)</h4>
                                <ul>${(result.strengths || []).map(s => `<li>${s}</li>`).join('') || '<li>-</li>'}</ul>
                            </div>
                            <div class="swot-item weaknesses">
                                <h4>⚠️ 약점 (Weaknesses)</h4>
                                <ul>${(result.weaknesses || []).map(w => `<li>${w}</li>`).join('') || '<li>-</li>'}</ul>
                            </div>
                            <div class="swot-item opportunities">
                                <h4>🌟 기회 (Opportunities)</h4>
                                <ul>${(result.opportunities || []).map(o => `<li>${o}</li>`).join('') || '<li>-</li>'}</ul>
                            </div>
                            <div class="swot-item threats">
                                <h4>⚡ 위협 (Threats)</h4>
                                <ul>${(result.threats || []).map(t => `<li>${t}</li>`).join('') || '<li>-</li>'}</ul>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 다음 단계 -->
                    <div class="report-next-steps">
                        <h3>🚀 권장 다음 단계</h3>
                        <ol class="next-steps-list">
                            ${(result.nextSteps || []).map(s => `<li>${s}</li>`).join('') || '<li>추가 분석 필요</li>'}
                        </ol>
                    </div>
                    
                    <!-- 성공 요인 -->
                    ${(result.successFactors || []).length > 0 ? `
                    <div class="report-success-factors">
                        <h3>🔑 핵심 성공 요인</h3>
                        <div class="success-factors-list">
                            ${result.successFactors.map(f => `<span class="success-factor">${f}</span>`).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- 액션 버튼 -->
                    <div class="report-actions">
                        <button class="btn btn-primary" onclick="exportReport()">📥 리포트 내보내기</button>
                        <button class="btn btn-ghost" onclick="resetAll()">🔄 새 분석 시작</button>
                    </div>
                </div>
            `;
        }

        function exportReport() {
            showToast('리포트 내보내기 기능은 준비중입니다', 'warning');
        }

        // ===== 컨텍스트 개입 =====
        function applyContext() {
            const context = document.getElementById('contextInput').value.trim();
            if (!context) {
                showToast('컨텍스트를 입력해주세요', 'warning');
                return;
            }

            if (state.currentStep === 0) {
                showToast('먼저 분석을 시작해주세요', 'warning');
                return;
            }

            // 되돌릴 지점 판단 (Agent 역할)
            const affectedStep = determineAffectedStep(context);
            document.getElementById('rollbackStep').textContent = getStepName(affectedStep);
            
            state.pendingContext = {
                text: context,
                affectedStep: affectedStep
            };

            openRollbackModal();
        }

        function determineAffectedStep(context) {
            // 간단한 키워드 기반 판단 (실제로는 LLM 사용)
            const contextLower = context.toLowerCase();
            
            if (contextLower.includes('페르소나') || contextLower.includes('유저') || contextLower.includes('타겟')) {
                return 3;
            }
            if (contextLower.includes('리스크') || contextLower.includes('위험') || contextLower.includes('검증')) {
                return 4;
            }
            if (contextLower.includes('태그') || contextLower.includes('분류')) {
                return 2;
            }
            
            return 3; // 기본값: 페르소나 단계
        }

        function getStepName(step) {
            const names = ['', '리뷰 수집', '태깅', '페르소나', '검증', '리포트'];
            return names[step] || '페르소나';
        }

        function quickIntervene(text) {
            document.getElementById('contextInput').value = text;
            applyContext();
        }

        async function confirmRollback(mode) {
            const { text, affectedStep } = state.pendingContext;
            
            addToHistory(text);
            
            // 사용자 컨텍스트를 state에 저장 (이후 LLM 호출 시 사용)
            if (!state.userContexts) state.userContexts = [];
            state.userContexts.push(text);
            
            log('context', `사용자 개입: "${text}"`);
            log('info', `영향받는 단계: <span class="highlight">${getStepName(affectedStep)}</span> (Step ${affectedStep})`);
            
            document.getElementById('contextInput').value = '';
            closeRollbackModal();
            
            if (mode === 'rerun') {
                log('info', `모드: <code>RERUN</code> - ${getStepName(affectedStep)} 단계부터 재실행`);
                showToast(`${getStepName(affectedStep)} 단계부터 재실행 중...`, 'success');
                
                // 해당 단계부터 재실행
                try {
                    if (affectedStep <= 3 && state.currentPhase === 1) {
                        // Phase 1 내 단계 재실행
                        await rerunFromStep(affectedStep);
                    } else if (affectedStep <= 8 && state.currentPhase === 2) {
                        // Phase 2 크리에이팅 재실행
                        await runCreatingPipeline();
                    } else if (state.currentPhase === 3) {
                        // Phase 3 검증 재실행
                        await runValidationPipeline();
                    }
                } catch (err) {
                    log('error', `재실행 실패: ${err.message}`);
                    showToast('재실행 실패: ' + err.message, 'error');
                }
            } else {
                // "현재 결과에 추가" 모드 - 현재 Phase의 마지막 단계만 재실행
                log('info', `모드: <code>APPEND</code> - 현재 결과에 컨텍스트 추가 반영`);
                showToast('컨텍스트를 반영하여 재분석 중...', 'success');
                
                try {
                    if (state.currentPhase === 3) {
                        // Phase 3: 검증만 재실행
                        await runValidationPipeline();
                    } else if (state.currentPhase === 2) {
                        // Phase 2: 크리에이팅 재실행
                        await runCreatingPipeline();
                    } else if (state.currentPhase === 1) {
                        // Phase 1: 페르소나만 재실행
                        await runStep(3, '페르소나', generatePersonas);
                    }
                    showToast('컨텍스트 반영 완료!', 'success');
                } catch (err) {
                    log('error', `재분석 실패: ${err.message}`);
                    showToast('재분석 실패: ' + err.message, 'error');
                }
            }
        }
        
        async function rerunFromStep(stepNum) {
            // Phase 1 단계 재실행
            const steps = [
                { num: 1, name: '리뷰 수집', fn: collectReviews },
                { num: 2, name: '태깅', fn: tagReviews },
                { num: 3, name: '페르소나', fn: generatePersonas }
            ];
            
            for (const step of steps) {
                if (step.num >= stepNum) {
                    await runStep(step.num, step.name, step.fn);
                }
            }
        }

        function addToHistory(text) {
            state.history.unshift({
                time: new Date(),
                text: text
            });

            renderHistory();
        }

        function renderHistory() {
            const historyEl = document.getElementById('historyList');
            
            if (state.history.length === 0) {
                historyEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-muted); font-size: 11px; padding: 10px;">
                        아직 개입 기록이 없습니다
                    </div>
                `;
                return;
            }

            historyEl.innerHTML = state.history.slice(0, 5).map(h => `
                <div class="history-item">
                    <div class="history-time">${formatTime(h.time)}</div>
                    <div class="history-text">${h.text}</div>
                </div>
            `).join('');
        }

        function formatTime(date) {
            const diff = Math.floor((new Date() - date) / 1000);
            if (diff < 60) return '방금 전';
            if (diff < 3600) return `${Math.floor(diff / 60)}분 전`;
            return `${Math.floor(diff / 3600)}시간 전`;
        }

        // ===== Phase 관리 =====
        function switchPhase(phaseNum) {
            if (phaseNum > 1 && !state.phaseCompleted[phaseNum - 1]) {
                showToast(`Phase ${phaseNum - 1}을 먼저 완료해주세요`, 'warning');
                return;
            }
            
            state.currentPhase = phaseNum;
            
            // 사이드바 Phase 탭 업데이트
            document.querySelectorAll('.phase-tab').forEach(tab => {
                tab.classList.remove('active');
                if (parseInt(tab.dataset.phase) === phaseNum) {
                    tab.classList.add('active');
                }
            });
            
            // 사이드바 Phase 콘텐츠 업데이트
            document.querySelectorAll('.phase-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`phaseContent${phaseNum}`).classList.add('active');
            
            // Phase 인디케이터 업데이트
            document.querySelectorAll('.phase-indicator-item').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.phase) === phaseNum) {
                    item.classList.add('active');
                }
            });
            
            // 파이프라인은 통합되어 항상 표시됨
            
            // 시작 버튼 텍스트 업데이트
            updateStartButton();
            
            // 메인 뷰 업데이트
            switchToView(0);
        }

        function updateStartButton() {
            const btn = document.getElementById('startBtn');
            
            // 현재 Phase가 완료되었는지 확인
            if (state.phaseCompleted[state.currentPhase]) {
                // 완료된 Phase - 다음 Phase로 이동 안내
                if (state.currentPhase < 3) {
                    const nextPhaseNames = {
                        1: '✓ 완료 → Phase 2로 이동',
                        2: '✓ 완료 → Phase 3로 이동'
                    };
                    btn.textContent = nextPhaseNames[state.currentPhase];
                    btn.onclick = () => switchPhase(state.currentPhase + 1);
                } else {
                    btn.textContent = '✓ 전체 완료';
                    btn.disabled = true;
                }
            } else {
                // 미완료 Phase - 시작 버튼
                const phaseNames = {
                    1: '페르소나 생성 시작',
                    2: '크리에이팅 시작',
                    3: '검증 시작'
                };
                btn.textContent = phaseNames[state.currentPhase] || '시작';
                btn.onclick = startCurrentPhase;
                btn.disabled = false;
            }
        }

        function enableNextPhase(phaseNum) {
            state.phaseCompleted[phaseNum] = true;
            
            // 현재 Phase 탭에 완료 표시
            const currentTab = document.querySelector(`.phase-tab[data-phase="${phaseNum}"]`);
            if (currentTab) {
                currentTab.classList.add('completed');
            }
            
            const nextPhase = phaseNum + 1;
            if (nextPhase <= 3) {
                const nextTab = document.querySelector(`.phase-tab[data-phase="${nextPhase}"]`);
                if (nextTab) {
                    nextTab.disabled = false;
                }
            }
            
            // Phase 인디케이터 업데이트
            const currentIndicator = document.querySelector(`.phase-indicator-item[data-phase="${phaseNum}"]`);
            if (currentIndicator) {
                currentIndicator.classList.add('completed');
            }
            
            // 시작 버튼 업데이트
            updateStartButton();
            
            // Phase 2 완료 시 검증 대상 업데이트
            if (phaseNum === 2 && state.creatingResult) {
                updateValidationTarget();
            }
        }

        async function startCurrentPhase() {
            switch (state.currentPhase) {
                case 1:
                    await startPhase1();
                    break;
                case 2:
                    await startPhase2();
                    break;
                case 3:
                    await startPhase3();
                    break;
            }
        }

        async function startPhase1() {
            // Phase 1: 페르소나 생성
            if (state.selectedRefs.length === 0) {
                showToast('Reference 게임을 최소 1개 선택해주세요', 'warning');
                return;
            }
            if (!state.apis.openai && !state.apis.anthropic) {
                showToast('API 키를 설정해주세요', 'warning');
                openSettingsModal();
                return;
            }

            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            btn.textContent = '진행 중...';

            try {
                log('info', '=== Phase 1: 페르소나 생성 시작 ===');
                
                // Step 1: 리뷰 수집
                await runStep(1, '리뷰 수집', collectReviews);
                
                // Step 2: 태깅
                await runStep(2, '태깅', tagReviews);
                
                // Step 3: 페르소나 생성
                await runStep(3, '페르소나', generatePersonas);

                // Phase 1 완료
                enableNextPhase(1);
                
                // 생성된 페르소나를 Phase 2 입력에 표시
                updateGeneratedPersonaChips();
                
                log('success', '=== Phase 1 완료 ===');
                showToast('페르소나 생성 완료! 결과를 확인 후 Phase 2로 진행하세요.', 'success');
                
                // 자동 전환하지 않고 현재 결과 화면 유지
                
            } catch (error) {
                log('error', `Phase 1 실패: ${error.message}`);
                showToast('페르소나 생성 실패: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                updateStartButton();
            }
        }

        async function startPhase2() {
            // Phase 2: 크리에이팅
            if (!state.idea.trim()) {
                showToast('아이디어를 입력해주세요', 'warning');
                return;
            }
            if (state.personas.length === 0) {
                showToast('Phase 1을 먼저 완료해주세요', 'warning');
                return;
            }

            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            btn.textContent = '진행 중...';

            try {
                log('info', '=== Phase 2: 크리에이팅 시작 ===');
                log('info', `아이디어: ${state.idea.substring(0, 100)}...`);
                
                // 멀티 에이전트 크리에이팅 실행
                await runCreatingPipeline();
                
                enableNextPhase(2);
                
                log('success', '=== Phase 2 완료 ===');
                showToast('크리에이팅 완료! 결과를 확인 후 Phase 3로 진행하세요.', 'success');
                
                // 자동 전환하지 않고 현재 결과 화면 유지
                
            } catch (error) {
                log('error', `Phase 2 실패: ${error.message}`);
                showToast('크리에이팅 실패: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                updateStartButton();
            }
        }

        async function startPhase3() {
            // Phase 3: 검증
            if (!state.creatingResult) {
                showToast('Phase 2를 먼저 완료해주세요', 'warning');
                return;
            }

            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            btn.textContent = '진행 중...';

            try {
                log('info', '=== Phase 3: 검증 시작 ===');
                
                await runValidationPipeline();
                
                enableNextPhase(3);
                
                log('success', '=== 전체 프로세스 완료 ===');
                showToast('검증 완료!', 'success');
                
            } catch (error) {
                log('error', `Phase 3 실패: ${error.message}`);
                showToast('검증 실패: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                updateStartButton();
            }
        }

        function updateValidationTarget() {
            const target = document.getElementById('validationTarget');
            if (!target || !state.creatingResult) return;
            
            const result = state.creatingResult;
            const items = [];
            
            if (result.game_director?.vision) {
                items.push(`🎮 비전: ${result.game_director.vision.substring(0, 50)}...`);
            }
            if (result.content_designer?.features) {
                items.push(`📝 기능: ${result.content_designer.features.length}개 제안`);
            }
            if (result.balance_designer?.concerns) {
                items.push(`⚖️ 밸런스: ${result.balance_designer.concerns.length}개 우려사항`);
            }
            if (result.system_designer?.components) {
                items.push(`⚙️ 시스템: ${result.system_designer.components?.length || 0}개 컴포넌트`);
            }
            if (result.synthesis) {
                items.push(`📊 종합 의견 포함`);
            }
            
            if (items.length > 0) {
                target.innerHTML = `
                    <div class="validation-summary">
                        <div class="validation-summary-title">✓ 크리에이팅 결과물 (Phase 2)</div>
                        <ul class="validation-items">
                            ${items.map(item => `<li>${item}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
        }

        function updateGeneratedPersonaChips() {
            const container = document.getElementById('generatedPersonaChips');
            const personas = state.results.step3?.personas || [];
            
            if (personas.length === 0) {
                container.innerHTML = '<div class="empty-personas">Phase 1을 먼저 완료해주세요</div>';
                return;
            }
            
            container.innerHTML = personas.map(p => `
                <div class="persona-chip">
                    <span class="avatar">${p.name.charAt(0)}</span>
                    <span>${p.name}</span>
                </div>
            `).join('');
            
            // state에도 저장
            state.personas = personas;
        }

        async function runCreatingPipeline() {
            // Phase 2: 멀티 에이전트 크리에이팅 파이프라인
            const personas = state.personas;
            const idea = state.idea;
            
            const agentSteps = [
                { step: 4, name: '게임 디렉터', key: 'game_director', emoji: '🎮' },
                { step: 5, name: '컨텐츠', key: 'content_designer', emoji: '📝' },
                { step: 6, name: '밸런스', key: 'balance_designer', emoji: '⚖️' },
                { step: 7, name: '시스템', key: 'system_designer', emoji: '⚙️' },
                { step: 8, name: '종합', key: 'synthesis', emoji: '📊' }
            ];
            
            const results = {};
            
            for (const agent of agentSteps) {
                // 단계 시작
                updatePipelineStep(agent.step, 'active', '진행중...');
                log('api', `LLM API 호출 - ${agent.name}`);
                console.log(`[Creating] Starting ${agent.name}...`);
                const startTime = Date.now();
                
                try {
                    let prompt;
                    if (agent.key === 'synthesis') {
                        // 종합 단계: 이전 결과들을 종합
                        prompt = `다음 게임 아이디어에 대한 각 에이전트의 의견을 종합해주세요.

[아이디어]
${idea}

[타겟 페르소나]
${personas.map(p => `- ${p.name}: ${p.description || ''}`).join('\n')}

[에이전트 의견]
${Object.entries(results).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join('\n')}

종합 의견과 다음 단계 제안을 자연스러운 문장으로 작성해주세요.`;
                    } else {
                        const rolePrompts = {
                            game_director: '게임 디렉터로서 전체 방향성과 비전을 제시해주세요. vision(한 문장 비전), key_points(핵심 포인트 3개 배열) 포함.',
                            content_designer: '컨텐츠 디자이너로서 구체적인 기능을 제안해주세요. features(기능 제안 3개 배열), suggestions(추가 제안 배열) 포함.',
                            balance_designer: '밸런스 디자이너로서 밸런스 관점을 검토해주세요. concerns(우려사항 배열), recommendations(권장사항 배열) 포함.',
                            system_designer: '시스템 디자이너로서 시스템 구조를 제안해주세요. architecture(아키텍처 설명), components(핵심 컴포넌트 배열) 포함.'
                        };
                        
                        // 사용자 컨텍스트 추가
                        const userContextStr = (state.userContexts && state.userContexts.length > 0) 
                            ? `\n[사용자 추가 지시사항]\n${state.userContexts.join('\n')}\n위 사항을 고려해서 제안해주세요.\n`
                            : '';
                        
                        prompt = `당신은 게임 개발팀의 ${agent.name}입니다.

[아이디어]
${idea}

[타겟 페르소나]
${personas.map(p => `- ${p.name}: ${p.description || ''}`).join('\n')}
${userContextStr}
${rolePrompts[agent.key]}

JSON 형식으로만 응답하세요.`;
                    }
                    
                    const response = await callLLM([
                        { role: 'system', content: agent.key === 'synthesis' 
                            ? '당신은 게임 기획을 종합하는 PM입니다. 자연스러운 문장으로 응답하세요.'
                            : '당신은 게임 개발 전문가입니다. JSON 형식으로만 응답하세요.' },
                        { role: 'user', content: prompt }
                    ], { temperature: 0.7, max_tokens: 1500 });
                    
                    log('info', `${agent.name} 토큰: +${response.tokens.toLocaleString()}`);
                    console.log(`[Creating] ${agent.name} response received`);
                    
                    let parsed;
                    if (agent.key === 'synthesis') {
                        parsed = response.content;
                    } else {
                        try {
                            const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                            parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                        } catch (e) {
                            parsed = { error: '파싱 실패', raw: response.content };
                        }
                    }
                    
                    results[agent.key] = parsed;
                    
                    // 단계 완료
                    updatePipelineStep(agent.step, 'completed', '완료');
                    log('success', `${agent.name} 완료`);
                    
                    // 중간 결과 표시
                    renderCreatingResult(results);
                    
                    // 다음 API 호출 전 딜레이 (rate limit 방지)
                    await new Promise(r => setTimeout(r, 1500));
                    
                } catch (err) {
                    updatePipelineStep(agent.step, 'completed', '실패');
                    log('error', `${agent.name} 실패: ${err.message}`);
                    results[agent.key] = { error: err.message };
                    console.error(`[Creating] ${agent.name} error:`, err);
                    
                    // 실패해도 다음 단계로
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
            
            state.creatingResult = results;
            state.results.creating = results;
            
            // 최종 결과 표시
            renderCreatingResult(results);
            log('success', '크리에이팅 파이프라인 완료');
        }

        async function runValidationPipeline() {
            // 검증 파이프라인 구현
            updatePipelineStep(9, 'active', '진행중...');
            log('api', 'LLM API 호출 - QA 검증');
            
            const creatingResult = state.creatingResult;
            const personas = state.personas;
            
            // 사용자 컨텍스트 추가
            const userContextStr = (state.userContexts && state.userContexts.length > 0) 
                ? `\n[사용자 추가 지시사항]\n${state.userContexts.join('\n')}\n위 사항을 검증 시 특히 고려해주세요.\n`
                : '';
            
            const prompt = `다음 크리에이팅 결과물을 QA 관점에서 검증해주세요.

[크리에이팅 결과]
${JSON.stringify(creatingResult, null, 2)}

[타겟 페르소나]
${personas.map(p => `- ${p.name}: ${p.pains?.join(', ')}`).join('\n')}
${userContextStr}
검증 기준:
- 밸런스/공정성
- 유저 경험 (UX)
- 기술적 실현가능성
- 운영/유지보수
- 수익화 영향

JSON 형식으로 응답:
{
  "overall_score": 1-100,
  "recommendation": "GO|GO_WITH_CAUTION|PIVOT|NO_GO",
  "validation_results": [
    { "category": "...", "score": 1-100, "issues": [...], "suggestions": [...] }
  ],
  "final_summary": {
    "verdict": "한 문장 핵심 결론",
    "key_strengths": ["검증을 통해 확인된 핵심 강점 1-2개"],
    "critical_risks": ["반드시 해결해야 할 핵심 리스크 1-2개"],
    "next_steps": ["구체적인 다음 단계 액션 아이템 2-3개"]
  }
}`;

            try {
                const response = await callLLM([
                    { role: 'system', content: '당신은 게임 QA 전문가입니다. JSON 형식으로만 응답하세요.' },
                    { role: 'user', content: prompt }
                ], { temperature: 0.3, max_tokens: 2000 });
                
                log('info', `토큰 사용: +${response.tokens.toLocaleString()}`);
                
                let parsed;
                try {
                    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
                    parsed = JSON.parse(jsonMatch ? jsonMatch[0] : response.content);
                } catch (e) {
                    parsed = { final_verdict: response.content, overall_score: 50 };
                }
                
                state.validationResult = parsed;
                state.results.validation = parsed;
                
                // 파이프라인 업데이트
                updatePipelineStep(9, 'completed', '완료');
                
                // 결과 표시
                renderValidationResult(parsed);
                
                log('success', `검증 완료 - 점수: ${parsed.overall_score}`);
                
            } catch (err) {
                updatePipelineStep(9, 'active', '오류');
                throw err;
            }
        }

        function renderCreatingResult(result) {
            const contentArea = document.getElementById('contentArea');
            
            const renderValue = (value, depth = 0) => {
                if (typeof value === 'string') {
                    return value;
                } else if (Array.isArray(value)) {
                    // 배열인 경우
                    if (value.length === 0) return '-';
                    if (typeof value[0] === 'string') {
                        return value.join(', ');
                    }
                    return value.map(v => renderValue(v, depth + 1)).join('; ');
                } else if (typeof value === 'object' && value !== null) {
                    // 객체인 경우
                    const name = value.name || value.title || '';
                    const desc = value.description || '';
                    const responsibilities = value.responsibilities;
                    
                    // name + description 조합
                    if (name && desc) {
                        return `<strong>${name}</strong>: ${desc}`;
                    }
                    // name + responsibilities (배열)
                    if (name && Array.isArray(responsibilities)) {
                        return `<strong>${name}</strong>: ${responsibilities.join(', ')}`;
                    }
                    if (name) return name;
                    if (desc) return desc;
                    
                    // 다른 키들 - 문자열만 추출
                    const stringValues = Object.entries(value)
                        .filter(([k, v]) => typeof v === 'string')
                        .map(([k, v]) => v);
                    if (stringValues.length > 0) {
                        return stringValues.join(' - ');
                    }
                    
                    // 최후의 수단
                    return Object.entries(value)
                        .slice(0, 3)
                        .map(([k, v]) => `${k}: ${typeof v === 'string' ? v : '...'}`)
                        .join(' · ');
                }
                return String(value);
            };
            
            const renderAgentCard = (title, emoji, data) => {
                if (!data || data.error) return '';
                
                let content = '';
                if (typeof data === 'string') {
                    content = `<p>${data}</p>`;
                } else {
                    // 객체를 보기 좋게 렌더링
                    Object.entries(data).forEach(([key, value]) => {
                        const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        if (Array.isArray(value)) {
                            content += `<div class="agent-section"><strong>${label}</strong><ul>${value.map(v => `<li>${renderValue(v)}</li>`).join('')}</ul></div>`;
                        } else if (typeof value === 'string') {
                            content += `<div class="agent-section"><strong>${label}</strong><p>${value}</p></div>`;
                        } else if (typeof value === 'object' && value !== null) {
                            // 중첩 객체도 보기 좋게
                            const nestedContent = Object.entries(value)
                                .map(([k, v]) => `<strong>${k}</strong>: ${typeof v === 'string' ? v : renderValue(v)}`)
                                .join('<br>');
                            content += `<div class="agent-section"><strong>${label}</strong><div class="nested-content">${nestedContent}</div></div>`;
                        }
                    });
                }
                
                return `
                    <div class="agent-card">
                        <div class="agent-card-header">${emoji} ${title}</div>
                        <div class="agent-card-body">${content || '<p class="empty">데이터 없음</p>'}</div>
                    </div>
                `;
            };
            
            contentArea.innerHTML = `
                <div class="creating-result">
                    <h2>🎮 크리에이팅 결과</h2>
                    <div class="agent-grid">
                        ${renderAgentCard('게임 디렉터', '🎮', result.game_director)}
                        ${renderAgentCard('컨텐츠 디자이너', '📝', result.content_designer)}
                        ${renderAgentCard('밸런스 디자이너', '⚖️', result.balance_designer)}
                        ${renderAgentCard('시스템 디자이너', '⚙️', result.system_designer)}
                    </div>
                    ${result.synthesis ? `
                        <div class="synthesis-card">
                            <div class="synthesis-header">📊 종합 의견</div>
                            <div class="synthesis-body">${result.synthesis}</div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderValidationResult(result) {
            const contentArea = document.getElementById('contentArea');
            const recText = {
                'GO': '✅ 진행 권장',
                'GO_WITH_CAUTION': '⚠️ 주의하며 진행',
                'PIVOT': '🔄 방향 전환 권장',
                'NO_GO': '❌ 진행 비권장'
            };
            
            // final_summary 또는 레거시 final_verdict 처리
            const summary = result.final_summary || {};
            const verdict = summary.verdict || result.final_verdict || '';
            const keyStrengths = summary.key_strengths || [];
            const criticalRisks = summary.critical_risks || [];
            const nextSteps = summary.next_steps || [];
            const validationResults = result.validation_results || [];
            
            // 카테고리별 검증 결과 렌더링
            const renderCategoryResults = () => {
                if (validationResults.length === 0) return '';
                
                return validationResults.map(cat => {
                    const scoreClass = cat.score >= 70 ? 'good' : cat.score >= 50 ? 'warning' : 'danger';
                    const issues = cat.issues || [];
                    const suggestions = cat.suggestions || [];
                    
                    return `
                        <div class="validation-category">
                            <div class="category-header">
                                <span class="category-name">${cat.category}</span>
                                <span class="category-score ${scoreClass}">${cat.score}점</span>
                            </div>
                            ${issues.length > 0 ? `
                                <div class="category-issues">
                                    <span class="issue-label">⚠️ 이슈</span>
                                    <ul>${issues.map(i => `<li>${i}</li>`).join('')}</ul>
                                </div>
                            ` : ''}
                            ${suggestions.length > 0 ? `
                                <div class="category-suggestions">
                                    <span class="suggestion-label">💡 개선점</span>
                                    <ul>${suggestions.map(s => `<li>${s}</li>`).join('')}</ul>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            };
            
            contentArea.innerHTML = `
                <div class="validation-result-full">
                    <div class="validation-header">
                        <h2>✓ QA 검증 결과</h2>
                        <div class="score-display">
                            <div class="score-circle">${result.overall_score || 0}</div>
                            <div class="score-info">
                                <div class="recommendation">${recText[result.recommendation] || result.recommendation}</div>
                                <p class="verdict-text">${verdict}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="validation-body">
                        <!-- 좌측: 카테고리별 상세 -->
                        <div class="validation-details">
                            <h3>📋 카테고리별 검증</h3>
                            <div class="validation-categories">
                                ${renderCategoryResults() || '<p class="empty">상세 검증 결과 없음</p>'}
                            </div>
                        </div>
                        
                        <!-- 우측: 요약 -->
                        <div class="validation-summary-panel">
                            ${keyStrengths.length > 0 ? `
                            <div class="summary-section strengths">
                                <h4>💪 핵심 강점</h4>
                                <ul>${keyStrengths.map(s => `<li>${s}</li>`).join('')}</ul>
                            </div>
                            ` : ''}
                            
                            ${criticalRisks.length > 0 ? `
                            <div class="summary-section risks">
                                <h4>⚠️ 핵심 리스크</h4>
                                <ul>${criticalRisks.map(r => `<li>${r}</li>`).join('')}</ul>
                            </div>
                            ` : ''}
                            
                            ${nextSteps.length > 0 ? `
                            <div class="summary-section next-steps">
                                <h4>🚀 다음 단계</h4>
                                <ol>${nextSteps.map(n => `<li>${n}</li>`).join('')}</ol>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // ===== 유틸리티 =====
        function resetAll() {
            // Phase 초기화
            state.currentPhase = 1;
            state.phaseCompleted = { 1: false, 2: false, 3: false };
            state.personas = [];
            state.creatingResult = null;
            state.validationResult = null;
            
            state.idea = '';
            state.genres = [];
            state.tags = [];
            state.selectedRefs = [];
            state.currentStep = 0;
            state.activeView = 0;
            state.totalTokens = 0;
            state.tokenDetails = [];
            state.results = {};
            state.history = [];
            
            // 토큰 디스플레이 초기화
            document.getElementById('tokenCount').textContent = '0';
            document.getElementById('footerTokens').textContent = '0 tokens';
            document.getElementById('footerCost').textContent = '$0.0000';

            // Phase UI 초기화
            switchPhase(1);
            document.querySelectorAll('.phase-tab').forEach((tab, i) => {
                tab.classList.remove('completed');
                if (i > 0) tab.disabled = true;
            });
            document.querySelectorAll('.phase-indicator-item').forEach(item => {
                item.classList.remove('completed');
            });
            document.getElementById('generatedPersonaChips').innerHTML = '<div class="empty-personas">Phase 1을 먼저 완료해주세요</div>';

            // 입력 초기화
            const ideaInput = document.getElementById('ideaInput');
            if (ideaInput) ideaInput.value = '';
            
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.tag-filter-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.ref-item').forEach(el => el.remove());
            document.getElementById('refEmpty').style.display = 'block';
            document.getElementById('refEmpty').textContent = '장르를 선택하면 추천이 표시됩니다';
            document.getElementById('refSearchInput').value = '';
            document.getElementById('refSearchResults').classList.remove('active');
            document.getElementById('tagFilterExpanded').style.display = 'none';
            document.getElementById('tagFilterExpandText').textContent = '(+12)';
            updateGenreCount();
            
            // 장르 확장 접기
            document.getElementById('genreGridExpanded').style.display = 'none';
            document.getElementById('genreExpandBtn').classList.remove('expanded');
            document.getElementById('genreExpandText').textContent = '(+12)';
            
            // 파이프라인 초기화
            document.querySelectorAll('.pipeline-step').forEach((step) => {
                step.className = 'pipeline-step pending';
                const icon = step.querySelector('.step-icon');
                const desc = step.querySelector('.step-desc');
                if (desc) desc.textContent = '대기중';
            });

            // 모든 스텝 뷰 초기화
            for (let i = 1; i <= 3; i++) {
                const contentEl = document.getElementById(`step${i}Content`);
                if (contentEl) {
                    contentEl.innerHTML = `
                        <div class="step-pending">
                            <div class="step-pending-icon">${i}</div>
                            <div class="step-pending-text">${getStepPendingText(i)}</div>
                        </div>
                    `;
                }
            }

            // 초기 뷰로 전환
            switchToView(0);
            
            updateProgress();
            updateSelectedRefCount();
            renderHistory();
            document.getElementById('footerInfo').textContent = '준비됨';
            updateStartButton();

            showToast('초기화되었습니다', 'success');
        }

        function getStepPendingText(step) {
            const texts = {
                1: '분석을 시작하면 리뷰 수집이 진행됩니다',
                2: '리뷰 수집 완료 후 태깅이 진행됩니다',
                3: '태깅 완료 후 페르소나 도출이 진행됩니다',
                4: '페르소나 도출 후 검증이 진행됩니다',
                5: '검증 완료 후 리포트가 생성됩니다'
            };
            return texts[step] || '';
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ===== 모달 =====
        function openSettingsModal() {
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function openPresetModal() {
            document.getElementById('presetModal').classList.add('active');
        }

        function closePresetModal() {
            document.getElementById('presetModal').classList.remove('active');
        }

        function openRollbackModal() {
            document.getElementById('rollbackModal').classList.add('active');
        }

        function closeRollbackModal() {
            document.getElementById('rollbackModal').classList.remove('active');
        }

        function selectPreset(preset, element) {
            document.querySelectorAll('.preset-option').forEach(el => el.classList.remove('active'));
            element.classList.add('active');
            state.preset = preset;
        }

        function applyPreset() {
            updatePresetUI();
            
            localStorage.setItem('vibeValidator_settings', JSON.stringify({
                apis: state.apis,
                preset: state.preset
            }));

            closePresetModal();
            showToast(`프리셋이 ${presetConfig[state.preset].name}으로 변경되었습니다`, 'success');
        }

        function updatePresetUI() {
            const config = presetConfig[state.preset];
            document.getElementById('currentPreset').textContent = config.name;
            document.getElementById('presetStatus').textContent = config.name;
            document.getElementById('presetDot').className = `preset-dot ${state.preset}`;
            
            document.querySelectorAll('.preset-option').forEach(el => {
                el.classList.toggle('active', el.dataset.preset === state.preset);
            });
        }

        // 모달 외부 클릭 시 닫기
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('active');
                }
            });
        });

        // ===== 패널 토글 =====
        function togglePanel() {
            const panel = document.getElementById('interventionPanel');
            const icon = document.getElementById('panelToggleIcon');
            
            panel.classList.toggle('collapsed');
            
            if (panel.classList.contains('collapsed')) {
                icon.textContent = '‹';
            } else {
                icon.textContent = '›';
            }
            
            // 상태 저장
            localStorage.setItem('vibeValidator_panelCollapsed', panel.classList.contains('collapsed'));
        }

        // 패널 상태 복원
        function restorePanelState() {
            const collapsed = localStorage.getItem('vibeValidator_panelCollapsed') === 'true';
            if (collapsed) {
                document.getElementById('interventionPanel').classList.add('collapsed');
                document.getElementById('panelToggleIcon').textContent = '‹';
            }
        }

        // 초기화 시 패널 상태 복원
        restorePanelState();
    </script>
</body>
</html>
